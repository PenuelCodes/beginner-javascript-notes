---
attachments:
  [
    Clipboard_2020-01-28-16-43-12 (2).png,
    Clipboard_2020-01-28-16-47-39 (2).png,
    Clipboard_2020-01-28-16-48-49 (2).png,
    Clipboard_2020-01-28-17-00-34.png,
    Clipboard_2020-01-28-17-05-22.png,
    Clipboard_2020-01-28-17-12-10.png,
    Clipboard_2020-01-28-17-15-30.png,
    Clipboard_2020-01-28-17-16-18.png,
    Clipboard_2020-01-28-17-17-04.png,
    Clipboard_2020-01-28-17-18-49.png,
    Clipboard_2020-01-28-17-25-44.png,
    Clipboard_2020-01-28-17-27-44.png,
    Clipboard_2020-01-28-17-31-06.png,
    Clipboard_2020-01-28-17-35-06.png,
    Clipboard_2020-01-28-17-35-44.png,
    Clipboard_2020-01-28-17-41-21.png,
    Clipboard_2020-01-28-19-48-01.png,
    Clipboard_2020-01-28-19-54-21.png,
    Clipboard_2020-01-28-19-59-14.png,
    Clipboard_2020-01-28-20-05-33.png,
    Clipboard_2020-01-28-22-28-03.png,
    Clipboard_2020-01-28-22-28-19.png,
    Clipboard_2020-01-29-15-31-21.png,
    Clipboard_2020-01-29-15-31-32.png,
    Clipboard_2020-01-29-15-32-16.png,
    Clipboard_2020-01-29-15-50-59.png,
    Clipboard_2020-01-29-15-55-38.png,
    Clipboard_2020-01-29-15-57-14.png,
    Clipboard_2020-01-29-16-43-59.png,
    Clipboard_2020-01-29-16-44-48.png,
    Clipboard_2020-01-29-16-45-24.png,
    Clipboard_2020-01-29-16-50-48.png,
    Clipboard_2020-01-29-16-55-56.png,
    Clipboard_2020-01-29-16-57-30.png,
    Clipboard_2020-01-29-17-00-53.png,
    Clipboard_2020-01-29-17-01-04.png,
    Clipboard_2020-01-29-18-48-01.png,
    Clipboard_2020-01-29-18-48-13.png,
    Clipboard_2020-01-29-18-51-05.png,
    Clipboard_2020-01-29-18-51-45.png,
    Clipboard_2020-01-30-17-50-07.png,
    Clipboard_2020-01-30-17-51-04.png,
    Clipboard_2020-01-30-17-52-26.png,
    Clipboard_2020-01-30-19-48-27.png,
    Clipboard_2020-01-30-19-58-43.png,
    Clipboard_2020-01-30-20-06-08.png,
    Clipboard_2020-01-30-20-07-35.png,
    Clipboard_2020-01-30-20-25-18.png,
    Clipboard_2020-01-30-20-26-46.png,
    Clipboard_2020-01-30-20-27-19.png,
    Clipboard_2020-01-30-20-30-25.png,
    Clipboard_2020-01-30-20-43-26.png,
    Clipboard_2020-01-30-20-44-42.png,
    Clipboard_2020-01-30-20-57-19.png,
    Clipboard_2020-01-30-20-59-21.png,
    Clipboard_2020-01-30-21-06-26.png,
    Clipboard_2020-01-31-17-36-06.png,
    Clipboard_2020-01-31-17-36-25.png,
    Clipboard_2020-01-31-17-45-50.png,
    Clipboard_2020-01-31-17-46-02.png,
    Clipboard_2020-01-31-17-47-21.png,
    Clipboard_2020-01-31-17-47-38.png,
    Clipboard_2020-01-31-17-49-45.png,
    Clipboard_2020-01-31-17-52-29.png,
    Clipboard_2020-01-31-17-55-36.png,
    Clipboard_2020-01-31-17-57-25.png,
    Clipboard_2020-01-31-17-58-57.png,
    Clipboard_2020-01-31-18-15-45.png,
    Clipboard_2020-01-31-18-20-52.png,
    Clipboard_2020-01-31-18-22-08.png,
    Clipboard_2020-02-01-14-02-53.png,
    Clipboard_2020-02-01-14-03-17.png,
    Clipboard_2020-02-01-14-04-35.png,
    Clipboard_2020-02-01-14-19-44.png,
    Clipboard_2020-02-01-14-23-12.png,
    Clipboard_2020-02-01-14-26-11.png,
    Clipboard_2020-02-01-14-28-02.png,
    Clipboard_2020-02-01-14-29-12.png,
    Clipboard_2020-02-01-14-30-30.png,
    Clipboard_2020-02-01-14-32-34.png,
    Clipboard_2020-02-01-14-39-56.png,
    Clipboard_2020-02-03-17-29-52.png,
    Clipboard_2020-02-03-17-30-52.png,
    Clipboard_2020-02-03-17-31-47.png,
    Clipboard_2020-02-03-17-32-49.png,
    Clipboard_2020-02-03-17-34-11.png,
    Clipboard_2020-02-03-17-35-42.png,
    Clipboard_2020-02-03-17-37-13.png,
    Clipboard_2020-02-03-17-38-09.png,
    Clipboard_2020-02-03-17-39-21.png,
    Clipboard_2020-02-03-17-43-28.png,
    Clipboard_2020-02-03-17-47-27.png,
    Clipboard_2020-02-03-17-50-42.png,
    Clipboard_2020-02-03-17-55-27.png,
    Clipboard_2020-02-03-18-00-04.png,
    Clipboard_2020-02-03-18-03-09.png,
    Clipboard_2020-02-03-18-04-02.png,
    Clipboard_2020-02-03-18-04-09.png,
    Clipboard_2020-02-03-18-06-25.png,
    Clipboard_2020-02-03-18-08-26.png,
    Clipboard_2020-02-03-18-08-59.png,
    Clipboard_2020-02-03-18-10-14.png,
    Clipboard_2020-02-03-18-17-49.png,
    Clipboard_2020-02-03-18-18-28.png,
    Clipboard_2020-02-03-18-19-34.png,
    Clipboard_2020-07-21-17-33-20.png,
    Clipboard_2020-07-21-17-54-27.png,
    Clipboard_2020-07-21-19-47-57.png,
    Clipboard_2020-07-22-08-21-45.png,
  ]
title: "Module 2: Functions"
created: "2020-01-28T21:27:12.651Z"
modified: "2020-07-28T12:02:49.217Z"
---

# Module 2: Functions

## 12 - Functions - Built in

These videos are going to be about functions. We will get a good primer on what functions are, the core concepts, and an overview of the types of functions that you can write.

It will not be exhaustive, because there is so much more we need to learn in order to take advantage of functions. The rest of the course is going to be using functions, since they are like types, a fundamental building block of JavaScript and we will get good at functions because we will be writing them throughout this entire course.

So, functions, what are they?

They allow us to group together sets of statements.

As a refresher from previous videos, these are all statements ðŸ‘‡

![](@attachment/Clipboard_2020-01-28-16-43-12.png)

If you wanted to group all those statements together _(generally they are related to each other and generally they produce some sort of output)_, you could group them together inside of a function.

Functions can take in data, those are known as **arguments** _(we will discuss the difference between arguments and parameters shortly)_. When you pass data to a function, it is known as an argument.

Functions perform some work (a statement), and sometimes they also return a value.`

Let's look at an example in the console using `Math.max()` _(this is actually a method, and we will explain the difference between a function and a method shortly, it is not much)_.

If you run it in the console, it returns negative infinity.

![](@attachment/Clipboard_2020-01-28-16-47-39.png)

What we want to do is pass it some data, and it should return to us the maximum value.

For example, let's pass two numbers, 10 and 12. It will return to us the highest number (which is 12).

![](@attachment/Clipboard_2020-01-28-16-48-49.png)

Now what is going on there?

`Math.max(10, 12)` is a JavaScript statement. The values `10` and `12` that we are passing into the function are called **arguments**.

If you are passing multiple values to a function, you need to separate each value with a comma and it's best practice to include a space between each.

To repeat, the data that you pass to a function, the data that you give to a function in order for it to run is called an argument.

Sometimes, functions will return to you some data that is generally the answer or the computed output based on what you passed in.

For example, `Math.floor(2.4444)` will return `2`

Here we are passing one argument of `2.4444` and it returns to us the floor of that value which is `2`.

![](@attachment/Clipboard_2020-01-28-17-00-34.png)

### Built-in Functions

There are a whole bunch of built-in functions in JavaScript, whether you are using it in the browser or with node.

They come with all of these built in things, and we have already been using them because there is no way around it. The one that we have used the most so far is `console.log()`.

For example if you `console.log('hey`)`, it will return hey.

Interestingly enough, it also returns undefined.

![](@attachment/Clipboard_2020-01-28-17-05-22.png)

That is because the console.log function logs to the console, it does not return a value. Not all functions are meant to return a value, sometimes they just go off and do things without returning a value.

_Tip: You can tell in the console if something is a return or a statement by the `>` and `<.` arrows next to the line in the console. `>` indicates that it's a statement and `<.` indicates that it's the response to the statement._

![](@attachment/Clipboard_2020-01-28-17-12-10.png)

Some other built in functions we can use are ðŸ‘‡

`parseFloat()` which takes in a string and returns a number, it switches the type. For example ðŸ‘‡

```js
parseFloat("20.34543543");
```

![](@attachment/Clipboard_2020-01-28-17-15-30.png)

`parseInt()` takes in a string and returns a number without a decimal. For example ðŸ‘‡

```js
parseInt("20.3243423");
```

![](@attachment/Clipboard_2020-01-28-17-16-18.png)

We looked at `Math.round()`, `Math.floor()`, `Math.ceil()` already in previous lesson.

If you type `Date.now()` in the console it will return something like the following ðŸ‘‡

![](@attachment/Clipboard_2020-01-28-17-17-04.png)

`Date.now()` is a function that does not take in any arguments. What it returns to us is the number of milliseconds since January 1 1970.

If you go to https://epoch.now.sh, it's a tool that you can use to convert the millisecond value to a datetime. You can also do the opposite -- pick some date and time in the future and then it will return the millisecond value.

![](@attachment/Clipboard_2020-01-28-17-18-49.png)

We will go deeper into dates in future videos.

We also have functions that will work with something called the **DOM**, which are the HTML elements that are on the page.

Create a new file called `functions.html`, and use the html base snippet.

Add a paragraph tag inside of the body that says "hey, how ya doin?" and then add an empty script tag below.

Open that up in the browser. ðŸ‘‡

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Functions!!</title>
    <link rel="stylesheet" href="../base.css" />
  </head>

  <body>
    <p>Hey How ya doin?</p>
    <script></script>
  </body>
</html>
```

In the script section of `functions.html`, add the following code. that will run a function called `document.querySelector()`, to which we are passing a **selector** `p`. This built in function will find something that matches that selector and puts it into a variable, and we will log that variable.

```html
<script>
  const p = document.querySelector("p");
  console.log(p);
</script>
```

![](@attachment/Clipboard_2020-01-28-17-25-44.png)

There are a lot of other functions built in, some are mobile specific like `navigator.vibrate()`.

![](@attachment/Clipboard_2020-01-28-17-27-44.png)

Another useful thing is if you are not sure what arguments a function should take, you can refer to the Mozilla developer docs, in order to see what is going on.

In google, type "Navigator.vibrate()". Usually you will need to look for the Mozilla developer _(a tip is to include `mdn` at the end of your search so the Mozilla docs float to the top)._

The docs should explain what the method is, how it can be used, and what it returns.

![](@attachment/Clipboard_2020-01-28-17-31-06.png)

Let's look at a couple of more.

Clear the console.

In `functions.html`, add a lot of text, such as a few paragraphs of Lorem Ipsum.

_(Wes is using the Emmet extension for VS Code which allows him to type `lorem400` and hit tab to expand 500 words of lorem ipsum. You can manually search for a Lorem Ipsum generator online if do not have the Emmet extension.)_

Now if you refresh `functions.html` you will see a lot of text on the page.

![](@attachment/Clipboard_2020-01-28-17-35-44.png)

Add enough text so you can scroll on `functions.html`.

Now you should be able to type in the console `window.scrollTo(0, 600)`, and that should cause your window to scroll down 600 pixels.

If we search for `scrollTo` on Mozilla docs, it says it accepts arguments of a x and y coordinate, or you can pass it an options object.

The docs say that

> options is a ScrollToOptions dictionary

**Dictionary** is a word we use in JavaScript to represent an object, it's an object that has a number of set properties on it.

![](@attachment/Clipboard_2020-01-28-17-41-21.png)

##### Example #1 ðŸ‘‡

```js
window.scrollTo(0, 1000);
```

Example #2 ðŸ‘‡

```js
window.scrollTo({
  top: 100,
  left: 100,
  behavior: "smooth",
});
```

In the first example, we are passing two numbers but it's also an option to pass an object which has properties inside of it like `top`, `left`, and `behavior`.

Try typing into the console the following ðŸ‘‡

```js
scrollTo({top:500, left:0, behavior: 'smooth})
```

That page should cause the page to scroll down 500 pixels.

![](@attachment/scrollTo.gif)

`scrollTo` is an example of a function that does return anything, instead it just goes off and does some work for us.

---

## 13 - Functions - Custom

In this video we will get into making our own custom functions.

A function can do anything, and the real power of JavaScript comes when you define your own functions.

Functions group together a set of instructions, often taking in values (we talked about **arguments** earlier), doing some work and then returning value or set of values back to what requested it.

For this lesson, you need to make a new folder `/custom-functions` inside of `/playground`. Within that folder, create two files `index.html` and `cf.js`. Add a log of "it works!" in the js file, and add the HTML base snippet to the HTML page.

We will need to modify the `base.css` path because we made a folder so the path should now be `../../base.css` _(because we have to go up two levels to get to it)_.

Right before the closing body tag, add a script source tag like so ðŸ‘‡ and you should see "It works!" in the console.

```html
<script src="./cf.js">
```

![](@attachment/Clipboard_2020-07-21-17-33-20.png)

In this lesson, we are going to create a function called "Calculate Bill".

You can think of "Calculate Bill" (said in southern american accent) as a western gentlemen who is very good at going to restaurants and calculating what the bill would be regarding what the bill was, how much tip was, how much tax is. That is what our function will be responsible for doing.

There are going to be a few buzzwords as we go through, which we will explain as we go, starting .

The first one is that **functions are created or defined**, and they are later **called**.

When you make a function, when you author what it does, that is called a **function definition**.

Later on, when you want to **run** that function, that is called **calling** or **running** of a function.

### Defining a Function

There are a few ways to define a function. We are going to go over all the different approaches in the next videos but for now, we will go over the basic.

First you type `function` and then the name of the function. Function naming follows the exact same rules as variable naming which we went over in a previous video.

We are going to call it `calculateBill` ðŸ‘‡

```js
function calculateBill() {
  //this is a function body
}
```

What we have done is defined it, given it parenthesis and then you open and close a function block.  
Anything that goes inside the function block is called the **function body**, and is part of the function.

In the function body, add ðŸ‘‡

```js
console.log("Running Calculate Bill!!!");
```

Open `index.html` and in the browser and open the console. Try typing `calculateBill` in the console and hitting enter.

![](@attachment/Clipboard_2020-01-28-19-48-01.png)

A function works just like a variable in that you can call them by the name of it. However, when you put just the name of the function, you see the entire code, as shown ðŸ‘† above.

Now if we want to run the function we would have to enter into the console `calculateBill()`, which will log `Running Calculate Bill!!!!` in the console.

Add the following to `cf.js` to run the function right from our JavaScript. ðŸ‘‡

```js
// Function Definition
function calculateBill() {
  // this is the function body
  console.log("Running Calculate Bill!!");
}

//Function Call or **Run**
calculateBill();
```

### Returning Values

When we called `calculateBill()` in the console, it returned undefined.

![](@attachment/Clipboard_2020-01-28-19-54-21.png)

It does the work we asked it to do, and then it returns undefined. Often, functions will do a bunch of work and then return to you the result.

What we are going to do in our function is we will take in the following arguments, and it will return to us the total value:

- how much the dinner was
- the tax rate
- how much you want to tip

The way that works is we will assume the meal is 100 dollars, and we will multiply it by 1.13 because in Ontario the tax rate is 13%.

Now we can log the total value to the console.

```js
// Function Definition
function calculateBill() {
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = 100 * 1.13;
  console.log(total);
}

//Function Call or **Run**
calculateBill();
```

![](@attachment/Clipboard_2020-01-28-19-59-14.png)

_(ðŸ‘† This is a perfect example of the issue with floating point numbers mentioned in a previous video)_

You might be thinking "oh, now I have this nice total variable which I can just quickly access". However, if you type `total` in the console, it will return undefined.

Try that by adding the following code to `cj.fg` below the `calculateBill` function definition, refresh the page and look at the error in the console.

```js
console.log("total");
```

You should see an error

> total is not defined

![](@attachment/Clipboard_2020-07-21-17-54-27.png)

In VSCode, you may notice that ESLint is yelling at us as well that total is not defined.

This is something that we will get into called **scope**.

Variables that are created inside of a function are only available within that function, which is called block scoping _(we will cover block in more detail in the future)_. It is not available outside of it.

So how do we store the result of the calculation so we can access it using a variable? With returning!

When we called `calculateBill()` earlier, we got undefined returned in the console. To fix that, we need to return total.

`return` is a keyword in JavaScript.

```js
  const total = 100 * 1.13;
  console.log(total);
  return total;
}

//Function Call or **Run**
calculateBill();
```

Now when you call it in the console, you will see it returns the value.

![](@attachment/Clipboard_2020-01-28-20-05-33.png)

### Storing a Value Returned from A Function

How can we store that value?

The total variable is still not available to us. That is because we need to **capture** (another buzz word) the result of the function or capture the returned value of the function into a variable.

Modify the line of JavaScript with `calculateBill()` like so ðŸ‘‡

```js
const myTotal = calculateBill();
console.log(myTotal);
```

In the console, you can now access the variable `myTotal`. Modify the log like so ðŸ‘‡

```js
console.log($`Your total is $${myTotal}`);
```

That will print out the value and message in the console.

You may be wondering why we have two variables to hold the same value, `total` within `calculateBill()` and `myTotal` below the function.

The reason is that `total` variable is a **temporary variable**.

Since `total` is created inside of the function, it is only ever available inside of `calculateBill` and when the function is done running, that variable is **cleaned up** (or what is called **garbage collected** in JavaScript and it's no longer needed).

If you ever want to capture the value returned from `calculateBill()`, you have to stick it into a variable before you can go ahead and display it.

Another cool thing you can do with **interpolation** strings is you can actually run the function from within the log statement.

JavaScript is going to run the function first, and then whatever the return result is it will immediately be interpolated into that string.

```js
console.log(`Your total is $${calculateBill()}`);
```

---

## 14 - Functions - Parameters and Arguments

This video will focus on **arguments** and **parameters**.

In the `calculateBill()` function from the previous video, we hardcoded the tax amount.

A best practice in JavaScript is to keep your code **DRY**, which stands for **Don't Repeat Yourself**.

`calculateBill` would not be useful if it could only calculate the value assuming the bill is \$100 and a 15% tax rate, so we need to modify those hardcoded values.

To solve that, above the calculateBill function, we can declare variables for the bill total and taxRate.

Modify the code like so ðŸ‘‡

```js
const bill = 100;
const taxRate = 0.13;

function calculateBill() {
  console.log("Running calculate bill!!");
  const total = bill * taxRate;
  return total;
}
```

This will work, but that is not the best way to do it. Why?

`calculateBill` is relying on something called **global variables** _(which will be explained in future videos)_.

For right now, what you need to know is that `calculateBill` needs needs some data. When it is not passed data, it is instead reaching outside of the function in order to look up that data in a higher **scope**.

That is not great practice _(reaching outside of a function in order to get your data)_.

In `cf.js`, remove the last console.log and add the following ðŸ‘‡

```js
const myTotal = calculateBill();
const myTotal2 = calculateBill();
console.log(myTotal, myTotal2);
```

_TIP: You can log as many pieces of data as you want by separating the values with commas like in the example above._

The log will return the same value:

> \$100.13.

What if we wanted a different value? Could we do something like this? ðŸ‘‡

```js
const myTotal = calculateBill();
bill = 200;
const myTotal2 = calculateBill();
console.log(myTotal, myTotal2);
```

_(Note: you need to change the `bill` variable that is declared in `cf.js` to a `let` instead of a const so we can reassign it)_

If you refresh it, now it works.

However, we have been changing the variable by modifying out code each time we want to run it with different values. This is bad practice and it is how you get very brittle applications.

What we want to do is instead of reaching out, we will pass the data that we need into our functions.

First let's do a bit of cleanup. Get rid of the `let bill` and `const taxRate` variables. Get rid of lines of code where we are reassigning variables and declaring myTotal2 (`bill = 200; const myTotal2 = calculateBill()`) and the last log.

You should end up with the following code ðŸ‘‡

```js
// Function Definition
function calculateBill() {
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = bill * 1 + taxRate;
  return total;
}

const myTotal = calculateBill();
```

Now we want to take the variables bill and tax rate and we want to make them into something called **parameters** or **params** for your function.

When you define your function, you add params which let's you know that the function expects to be passed some data. Wes likes to think of params as placeholders.

```js
function calculateBill(billAmount, taxRate){
```

Inside of the function body, we will have access to the two variables that were passed:

- `billAmount`
- `taxRate`

It's can be confusing because there is no "creation of the param variables", but Wes will do his best to explain it.

```js
// Function Definition
function calculateBill(billAmount, taxRate) {
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = billAmount * (1 + taxRate);
  return total;
}

const myTotal = calculateBill(100, 0.13);
console.log(myTotal);
```

That will give you \$100.13.

But now we are able to make a `myTotal2` really quickly ðŸ‘‡

```js
const myTotal = calculateBill(100, 0.15);
const myTotal2 = calculateBill(200, 0.13);
console.log(myTotal, myTotal2);
```

It works without having to reassign because when you define a function, you can place parameters. P = placeholder is one way to remember it.

When you call the function, you pass it arguments.

Here is a quick cheatsheet Wes has put together that explains the parts of a function.

![](@attachment/Clipboard_2020-01-28-22-28-19.png)

When we define the function name, we put what are called **parameters**. Parameters can be thought of as placeholders (we will talk about **default values** for parameters shortly).

When you **call**, **run** or **invoke** (all 3 mean the same thing), and you actually pass it the data, that will take place of the variables (for example `meal` will be `100` and `taxRate` will be `10.13`), those will be called **arguments**.

People incorrectly use those terms interchangeably. One way to remember is that _parameters are placeholders_. The actual values that you pass in when calling a function are what are called **arguments**.

Bringing it back to `const myTotal = calculateBill(100,0.13)`, here we are running the function and as arguments we are passing straightaway numbers. However, the values that get passed into a function can be in a variable as well. This is a common thing people get hung up on when learning how functions work is how they sort of get renamed.

Let's take a look at code we wrote for `calculateBill()`.

The data gets passed into the function, and those variables are only available inside of the `calculateBill` function. They will be what is called **scoped to the function**, which means only available inside of the function.

If we add a log within calculateBill like so ðŸ‘‡

```js
// Function Definition
function calculateBill(billAmount, taxRate) {
  console.log(billAmount, taxRate);
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = billAmount * (1 + taxRate);
  return total;
}
const myTotal = calculateBill(100, 0.15);
```

![](@attachment/Clipboard_2020-01-29-15-31-32.png)

We can run that function from the console but pass it different values for the arguments, it will console log the values of the arguments that we passed, like so ðŸ‘‡

![](@attachment/Clipboard_2020-01-29-15-32-16.png)

Why?

Because JavaScript will take whatever you write as an argument, and then when you call the function it will make it sort of temporarily available to you via the names that you put in your parameters.

What gets a little bit confusing to people is if we declare two variables before we call the function like so ðŸ‘‡

```js
const wesTotal = 500;
const wesTaxRate = 0.3;
const myTotal = calculateBill(100, 0.15);
```

We can actually pass those variables into the function like this ðŸ‘‡

```js
const wesTotal = 500;
const wesTaxRate = 0.3;
const myTotal = calculateBill(wesTotal, wesTaxRate);
```

Now the big confusion is, if they are variables outside of the function, and we pass them into the function, when it's called inside of the function, is the first parameter called `billAmount` or is it called `wesTotal`?

Will it even work if you pass in a variable that does not have the same name as the parameter? Try refreshing `index.html` in the browser.

_**You should see it works just fine!**_

To review, when you run a function in JavaScript, what happens is JavaScript takes in whatever you have pass it, whether you have passed it that value directly _(as a number or string for example)_, or if you pass it in via reference _(meaning that you just passed a reference to a variable which in turn will hold a value)_.

At the end of the day we are still passing values, whether you pass it directly or whether you pass it a reference to a variable that holds a value. JavaScript doesn't care about how you are passing them in, whether as a value directly or as a variable.

In this function, JavaScript will take whatever was passed in the first argument and make it into a temporary variable `billAmount` that is available inside of the confines of the curly brackets.

When the function is running, it does not care about anything else that is going outside of this function. It just knows it's doing it's job, it's been passed in the 2 little pieces of data that it needs, it does the math and returns it's value from within the function.

When values get passed into a function, they sort of get renamed into whatever it is that you have defined your function parameters as.

### Another Example

Let's do another example!

Comment out the code `const myTotal = calculateBill...`.

Add the following function to your code, which just returns hello and which we will pass in someone's first name ðŸ‘‡

```js
function sayHiTo() {
  return `Hello ${firstName}`;
}
const greeting = sayHiTo();
console.log(greeting);
```

Run the code as is, even though it will break, to see why. In the console you should see an reference error in the console.

![](@attachment/Clipboard_2020-01-29-15-50-59.png)

What happens is this function, first it looks inside of it's own function scope, and it will look for a variable `firstName` that has been passed in. If there is not, it will start to do is go up to a high level of scope and look there.

Let's say there was a firstName variable like so ðŸ‘‡

```js
const firstName = "wes";
function sayHiTo() {
  return `Hello ${firstName}`;
}
const greeting = sayHiTo();
console.log(greeting);
```

That would work, because the function will reach outside for that data if nothing is found within the scope of that function.

What we want to do is modify the function definition to set it to take in one parameter (`firstName`). And then when we run the function, we actually have to pass it a string (we will use `Wes`), and then we will have our greeting.

```js
const firstName = "wes";
function sayHiTo(firstName) {
  return `Hello ${firstName}`;
}
const greeting = sayHiTo("Wes");
console.log(greeting);
```

This makes the function nice and reusable, and we can use it to print out any first name like so ðŸ‘‡
![](@attachment/Clipboard_2020-01-29-15-55-38.png)

As long as we pass in an argument (in this case "Wes"), it is going to have a variable inside of that function that is referenced to whateer the person has passed in.

If we don't run it with anything, you will see... ðŸ‘‡

![](@attachment/Clipboard_2020-01-29-15-57-14.png)

The reason that happens is when a function runs, it will create the variable for us (`firstName`) and set it to whatever was passed in.

But if it creates a variable and someone doesn't pass in anything, then it will just be set to undefined which is exactly how variables work.

### Even More Example

Now let's go over a few more examples.

Let's go back to passing expressions. For this example we will go back to `calculateBill`.

```js
// const greeting = sayHiTo('Wes');
// console.log(greeting);
const myTotal3 = calculateBill(100, 0.15);
```

We know the code above works but what if instead we do ðŸ‘‡

```js
const myTotal3 = calculateBill(20 + 20 + 30 + 20, 0.15);
```

Is that going to work?

If you load `index.html` in the broswer you will see `103.4999999999`.

_(If you followed Wes too closely, you may have gotten the value of 90.5. If that is the case, the line of code that calculates the total within `calculateBill`. It should be `const total = billAmount * ( 1 + taxRate);`. This is because of bedmas, we need the paranthesis)._

That works.

Why?

Because the only thing that a function can take in is a value, and whether you pass that value directly, as in a number, whether you pass that value in as a variable which holds a value, that works, and then you can also pass in expressions.

In this example we are not actually passing an expression, we are actually running an expression and that will first run (`20 + 20 + 30 + 20`) and add it up to \$90, and then we pass that raw value of 90.

It is absolutely fine to do something that like, in fact it is pretty common.

You can even mix and match.

Let's say we have a variable `const kait = 100;` and then we want to add another \$50 on top of that. You can do something like..

```js
const kait = 100;
const myTotal3 = calculateBill(kait + 50, 0.15);
```

It still works, even though we are mixing and matching.

Let's remove the `myTotal3` example, and do another example where we pass functions as arguments.

Make a function `doctorize` which will take in a `name` argument and return the name with "Dr." in front like so ðŸ‘‡

```js
function doctorize(name) {
  return `Dr. ${name}`;
}
```

And we will make another function called `yell` that also takes in a name and returns "HEY" with the variable name uppercase like so ðŸ‘‡

```js
function yell(name) {
  return `HEY ${name.toUpperCase()}`;
}
```

You might have noticed that both functions are using the variable `name`.

While it's not okay to reuse variables in the same scope multiple time, it is okay to reuse parameters.

Why? Because when arguments are passed in, the parameters are only available within that function so you will never run into a collision where the name that you pass into one function is going to overwrite it in the other function. That will not happen because _parameters are scoped to the confines of their own functions._

The `name` parameter that is used in the `doctorize()` method will never collide with the variable within the `yell()` method.

Let's go ahead and run it in the console. ðŸ‘‡

![](@attachment/Clipboard_2020-01-29-16-43-59.png)

Let's pass the output of `doctorize()` into `yell` by typing the following into the console ðŸ‘‡

```js
yell(doctorize('wes))
```

![](@attachment/Clipboard_2020-01-29-16-44-48.png)

How that works is:

- brackets go first. anything in between the yell parenthesis `yell()` the code says "okay, I need to first run this function first" , and hopefully that returns a value (which it does, it returns Dr. + the value of the `name` argument passed)
- then the value that is returned from `doctorize` immediately gets passed into `yell` as an argument and then that will in turn return "Hey Dr. Wes".

So to recap -- another way we can pass a value to a function that is the output of a function, because that is just a value at the end of the day and you can run that directly like demonstrated here.

**Default Values**

Now, let's talk about **default values**.

If we were to take our `yell` function and instead of passing it "Wes", we do not pass an argument, it will error out.

![](@attachment/Clipboard_2020-01-29-16-50-48.png)

What is happening is that the `toUpperCase()` function (it's technically a method), it's trying to run it against something that didn't get passed in. This means that is someone forgets to pass a value to the `yell` function, our code will break.

What we can do is we can set something called **defaults**. When you define your function, inside of your function definition, you can set a default by saying name is equal to 'Silly Goose', as shown below.

```js
function yell(name = "Silly Goose") {
  return `HEY ${name.toUpperCase()}`;
}
```

If you run it and pass an argument, it will still work.

However when you run it without an argument, the function will no longer error out and instead will fall back to the default value for the parameter and output `HEY SILLY GOOSE`.

So as you define your function, you can specify if someone does not pass this parameter `name`, use the default.

Let's go back to our `calculateBill` function.

You may be thinking that it's a bit silly to have to pass in the the tax rate every single time. We will use a default value to set a default tax rate of 0.13, by modifying the function like so ðŸ‘‡

```js
// Function Definition
function calculateBill(billAmount, taxRate = 0.13) {
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = billAmount * (1 + taxRate);
  return total;
}
```

What that allows us to do is call `calculateBill(100)` and only pass the value for the `billAmount`.

![](@attachment/Clipboard_2020-01-29-16-55-56.png)

Wes often likes to set default values when he is creating functions. Even just adding a default value for a string variable of an empty string.

```js
function yell(name = "") {
  return `HEY ${name.toUpperCase()}`;
}
```

That will make sure the function doesn't error out, it just won't show a name like so ðŸ‘‡

![](@attachment/Clipboard_2020-01-29-16-57-30.png)

That is just a safeguard.

Let's take it one step further and modify `calculateBill` to also take in a tip rate.

Add another argument with a default value `tipRate = 0.15` ðŸ‘‡

```js
// Function Definition
function calculateBill(billAmount, taxRate = 0.13, tipRate = 0.15) {
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = billAmount * (1 + taxRate);
  return total;
}
```

Now we will change the way we calculate total like so ðŸ‘‡

```js
const total = billAmount + billAmount * taxRate + billAmount * tipRate;
```

You may notice that as you save the file, Prettier will remove the parenthesis if they are not needed (the BEDMAS rules are not needed here)

BEFORE SAVING ðŸ‘‰ ![](@attachment/Clipboard_2020-01-29-17-00-53.png)

AFTER SAVING WITH PRETTIER ðŸ‘‰ ![](@attachment/Clipboard_2020-01-29-17-01-04.png)

If we run `calculateBill` and pass it 100 dollars, it will return 128.

### How to Fall Back on Default for Only One Parameter

A gotcha that happens here is _what if you want to use the default tax rate but not the default tipRate?_

```js
const myBill4 = calculateBill(100, ,0.2);
```

If you try to just leave the argument empty and use two commas like shown above ðŸ‘†, it will break.

![](@attachment/Clipboard_2020-07-21-19-47-57.png)

ðŸ‘† The error is complaining about an unexpected token `,`.

So the only thing that you can pass into a function to cause it to use the default is **undefined**. A function will only ever fall back to the defaults if nothing is passed.

Remember when a variable is not set to anything, it's value is `undefined`. So you cannot go ahead and pass zero here and expect it to false back to the default.

```js
const myBill4 = calculateBill(100, undefined, 0.2);
```

You have to actually pass it `undefined`, ðŸ‘† as shown above, and it will work as we intended.

It's very infrequently that you have to pass `undefined` like that but it's worth knowing how a function decides whether or not to fall back on a default.

It has nothing to do with **truthy** or **falsy** which we will be learning soon.

---

## 15 - Different Ways to Declare Functions

One thing you will hear often when getting into JavaScript is that functions are _"first class citizens"_.

JavaScript functions are values in themselves, and they can be stored in variables and passed into other functions.

What _is_ a **value** in JavaScript?

We know that in the examples below ðŸ‘‡ that `true` and `100` are values.

```js
const age = 100;
const cool = true;
```

Those are values that are numbers, or strings or booleans.

What is cool about JavaScript is that functions can be:

- passed into other functions.
- stored in variables,
- moved around like any other piece of data in JavaScript

That is not true for every other programming language.

Let's start by looking at how you can put a function into a variable, and then look at the different ways to declare functions.

Create a new file `ways-to-make-a-function.js` in the `/custom-functions` directory.

```HTML
<script src="./ways-to-make-a-function.js"></script>
```

Add a log of "it works!" and go back to the `index.html` file and change the path in the script source attribute as shown above ðŸ‘† and refresh the browser to ensure it works.

We already know one way to declare a function and that is using the function keyword, like so ðŸ‘‡

```js
function doctorize(firstName) {
  return `Dr. ${firstName}`;
}
```

#### Anonymous Functions

Let's look at some other options we have when declaring functions, starting with an **anonymous function**, which is a function without a name.

To make `doctorize` an anonymous function, you would modify it like this ðŸ‘‡

```js
function(firstName){
  return `Dr. ${firstName}`;
}
```

However, that is not valid JavaScript. If you try running it in the console you will see an error that says ðŸ‘‡

> SyntaxError: Function statements require a function name

![](@attachment/Clipboard_2020-07-22-08-21-45.png)

Anonymous functions are only valid in some use cases, such as using them in **callbacks** (we will learn more about that later) as well as in an **IIFE (immediately invoked function expression)**. This example was not a valid use case.

Why would you ever want an anonymous function?

#### Function Expressions

The next way we will cover to declare a function will help explain that, which is as a **function expression**.

Add a comment above that function specifying that it is an anonymous functions, then copy the function and comment it out.

Paste the copied code below the commented out function.

The next way to declare a function is a **function expression**. A function expression is when you store a function as a value in a variable. ðŸ‘‡

```js
//Function Expression
const doctorize = function (firstName) {
  return `Dr. ${firstName}`;
};
```

In the code above ðŸ‘†, we have taken the anonymous function and stuck it in a variable.

If you refresh the page, you will see that in the console, we have `doctorize()` available to us, and we can call it like we did in previous videos.

![](@attachment/Clipboard_2020-01-29-18-48-13.png)

Having the ability to create a variable and then store it in a function is what leads people to say functions are _"first class citizens"_.

You may come across developers who say to not use function expressions because they used to give unhelpful errors.

Previously, anonymous function errors would just tell you that it occurred in an anonymous function, without giving you any clue where the error is happening. However, now the dev tool errors are better.

Here is an example that demonstrates what they mean by that ðŸ‘‡

```js
//Function Expression
const doctorize = function (firstName) {
  doesntExist();
  return `Dr. ${firstName}`;
};
```

![](@attachment/Clipboard_2020-01-29-18-51-45.png)

In our case, it does now tell you it happens inside of doctorize on line 12.

Although the function is technically an anonymous function without a name, the browsers will now infer the name of the function from the variable name and use that in the errors.

#### What is the difference between a function declaration and a function expression?

What is the difference between doing a function declaration and a function expression? Why would you want to use one over the other?

##### Hoisting

There is only one real difference which is how they operate in something called **hoisting**. We will go over this in detail a future video but for now we will just quickly cover the concept.

Duplicate the `doctorize` function and name it `doctorize2`, like ðŸ‘‡

```js
const doctorize = function (firstName) {
  return `Dr. ${firstName}`;
};
function doctorize2(firstName) {
  return `Dr. ${firstName}`;
}
```

Let's say right before the first `doctorize` function, we called `doctorize` and passed it the value of "wes", as shown below ðŸ‘‡, do you think the code will run?

If you run a function before you define it, does it work? Refresh the page and look at the console to test it

```js
doctorize("wes");
const doctorize = function (firstName) {
  return `Dr. ${firstName}`;
};
function doctorize2(firstName) {
  return `Dr. ${firstName}`;
}
```

Did it work?

Nope! You get an error like:

> Uncaught ReferenceError: Cannot access 'doctorize' before initialization
> at ways-to-make-a-function.js:78
> (anonymous) @ ways-to-make-a-function.js:78

What about `doctorize2`?

```js
console.log(doctorize2("wes"));

const doctorize = function (firstName) {
  return `Dr. ${firstName}`;
};
function doctorize2(firstName) {
  return `Dr. ${firstName}`;
}
```

It does work!

Why does a function declaration work if you call it before you define it, but a function expression does not, especially when we created the exact same function in both cases?

Functions that are declared with the **function** keyword are called **hoisted**.

JavaScript will take all functions with the function keyword and and hoist them up, up, up and says "you're a function, you belong at the top of the file". That means anywhere you cal the function, it will be available to you.

JavaScript does **not** hoist variable functions.

Why is that useful?

Very rarely, Wes has never used that in his entire career except tiny use cases.

**Hoisting** is more of an interview question that you may be asked.

Essentially it means that JavaScript will take functions and bring them up to the top of the code before they are called. This gives us the ability to run a function before it is defined.

Remove the `doctorize2` function from the JavaScript file which should leave just the function expression.

### Arrow Functions

The next way to make a function is using an **arrow function**.

Arrow functions themselves have a few different ways of being declared. They are a newer addition to JavaScript, and were added in the last couple of years.

They have a few benefits:

- concise syntax and tend to be shorter. allow for writing one line functions
- do not have their own scope in reference to the `this` keyword _(we will cover the `this` keyword in future video)_

Arrow functions are also **anonymous functions**, which means there is no way to declare an arrow function the way we do a function declaration `function doctorize(){..}`. You always have to stick it into a variable.

To illustrate this, we will begin by writing a regular function. ðŸ‘‡

```js
function inchToCM(inches) {
  const cm = inches * 2.54;
  return cm;
}
```

This function will take in inches and return centimeters.

Let's try it out in the browser.

![](@attachment/Clipboard_2020-01-30-17-50-07.png)

This is a pretty simple function, but it still takes up 4 lines of code.

We can make it a bit shorter by instead of creating a variable and then returning a variable, we can just return the calculation directly.

```js
function inchToCM(inches) {
  return inches * 2.54;
}
```

![](@attachment/Clipboard_2020-01-30-17-52-26.png)

_Note: You may notice in the above ðŸ‘† screenshot that the line of code with `return cm;` is now greyed out. That is because that code will never be reached, since we are returning in the line of code above it. When you return from a function, the function stops running._

Now we can convert it to an anonymous function as a step on the way to making it an arrow function.

```js
const inchToCM = function (inches) {
  return inches * 2.54;
};
```

Refresh the page to check that it still works, which it should. All we have done if turned it into an anonymous function and stored it in a variable.

### Different Ways to Write Arrow Functions

Let's convert it to an arrow function now, which we can do a few different ways.

Instead of writing the word function, we will delete it like so ðŸ‘‡

```js
const inchToCM = (inches){
  return inches * 2.54;
}
```

Now we will go to the right of the parenthesis and add what is called a **fat arrow** `=>`.

In programming, `->` is referred to as a **skinny arrow** and `=>` is referred to as a **fat arrow**.

```js
const inchToCM = (inches) => {
  return inches * 2.54;
};
```

When you save, you might notice that Prettier modified the function for you and removes the parenthesis, which is not what we want because we are trying to change it to an arrow function in steps. to di To disable that, add `/* eslint-disable */` right above the function.

_The spaces between the parenthesis and the arrow in the following code ðŸ‘‰ `(inches) => {` does not have to be there, this is the same code with different whitespace and ðŸ‘‰ `(inches)=>{` still works, but it's more readable with spaces._

If you refresh the page and run it in the console, you will see that it still works.

### Implicit and Explicit Returns

The next thing we will do is what is called an **implicit return**.

An **explicit return** is when you type the `return` keyword before returning a value such as ðŸ‘‡

```js
return inches * 2.54;
```

That is an explicit return meaning that _we explicitly return the value there_.

An **implicit return** is returning it without actually having to type the keyword `return`. Arrow functions allow us to use implicit returns.

Let's start by putting the function on one line, like so ðŸ‘‡

```js
const inchToCM = (inches) => {
  return inches * 2.54;
};
```

To get rid of the **explicit** return:

- first put the function on one line
- then delete the curly brackets`{` `}`
- finally delete the keyword

```js
const inchToCM = (inches) => inches * 2.54;
```

Your code should look like the above ðŸ‘†

What we did there is:

- we made an arrow function `inchToCM` which takes in one argument, `inches`
- modified the function to implicitly return the value.

The way we can tell this is an implicit return is that:

1. it's all on one line
2. there is no return keyword
3. there are no curly brackets

If you refresh in the browser, you will see that it still works.

_To recap: what we did there is we removed the function block, modified the code to be on one line, and removed the explicit return._

Finally, and this is more of a stylistic choice, if there is only ever one parameter for your function, you can actually get rid of the parenthesis around the parameter as well, like soðŸ‘‡

```js
const inchToCM = (inches) => inches * 2.54;
```

If there is only one parameter in your arrow function, you can remove them no problem. It is still a valid arrow function.

Let's do another example!

Make a function called `add`, that takes in two parameters `a` and `b`, with the default value of `b` being 3. We will then we make a temporary variable called total which we return.

```js
function add(a, b = 3) {
  const total = a + b;
  return total;
}
```

Pause here, try to convert it to an arrow function yourself and then come back once you have tried it.

Let's first see if it works as it originally was.

Save the code from above ðŸ‘† and refresh `index.html` in the browser.

Open the console and test the function.

![](@attachment/Clipboard_2020-01-30-19-48-27.png)

You might notice that dev tools is giving us an annotation `?b` in `Æ’(a,?b)` as shown above.

That little question mark in front of `b` is telling us that the argument is optional. `b` if optional because there is a default value to fall back on.

Stick the function in a variable `add` and remove the function name, like so ðŸ‘‡

```js
const add => function(a, b = 3) }
```

Next, convert it to an arrow function. Get rid of the keyword function and add a fat arrow to the right of the parenthesis, as shown below.

```js
const add = (a, b = 3) => {
  const total = a + b;
  return total;
};
```

Modify the code to return `a + b` and get rid of the total variable. ðŸ‘‡

```js
const add = (a, b = 3) => {
  return a + b;
};
```

Put the function on one line.

```
const add = (a,b = 3) => { return a + b; }
```

Get rid of the function block and the `return` keyword like so ðŸ‘‡

```js
const add = (a, b = 3) => a + b;
```

Now we have a short arrow function!

You may have noticed that we did not get rid of the parentheses, and that is because there is more than one parameter.

### Arrow Function Gotcha's

There are a couple of other gotchas with arrow functions that we need to know about.

Let's go over them now.

##### Returning an object

Let's make a function `makeABaby()`, which will accept a first and last name for the baby.

Inside of the function, create an object `baby` with a `name` and `age` property. ðŸ‘‡

```js
function makeABaby(first, last) {
  const baby = {
    name: `${first} ${last}`,
    age: 0,
  };
  return baby;
}
```

It works!

![](@attachment/Clipboard_2020-01-30-19-58-43.png)

How could you convert this to an arrow function?

Stick, stick it in a variable, and convert it to an arrow function like so ðŸ‘‡

```js
const makeABaby = (first, last) => {
  const baby = {
    name: `${first} ${last}`,
    age: 0,
  };
  return baby;
};
```

If your function needs to do some stuff inside of the block, you can leave it as is. This is a perfectly valid arrow function.

If the only thing you're using the arrow for is the ability to type less as well as some of the benefits of not scoping this, this is totally valid.

However we can take it a bit further.

Instead of declaring the `baby` variable we will just return the object directly. ðŸ‘‡

```js
const makeABaby = (first, last) => {
  return {
    name: `${first} ${last}`,
    age: 0,
  };
};
```

Now the question is... how would we do the implicit return?

We can put it on one line, no problem _(objects can be put on one line)_.

But how would we return it?

Let's try it the way we know.

Put it on one line.

```js
const makeABaby = (first, last) => {
  return { name: `${first} ${last}`, age: 0 };
};
```

To make it an implicit return, get rid of the curly brackets and the `return` keyword. ðŸ‘‡

```js
const makeABaby = (first, last) => { name: `${first} ${last}`, age: 0};
```

![](@attachment/Clipboard_2020-01-30-20-06-08.png)

However, you will see the above ðŸ‘† error if you try to run the code like that.

Whats happening there is it thinks that the curly bracket from the baby object is actually the curly object from the block of the function.

Curly brackets in JavaScript can be creation of an object, or a block of code.

What are you options to implicitly return an object then?

If you want to implicitly return an object in JavaScript, you just pop a set of parentheses around the thing that you are returning and then the code will know that it's not the block to the function.

Try it by modifying your code like so ðŸ‘‡

```js
const makeABaby = (first, last) => ({ name: `${first} ${last}`, age: 0 });
```

If you try it in the code, it still works.

Now... is there a benefit of having the function this way or how we did it originally? Wes doesn't think so.

You're not really getting much benefit, in fact the way we had it originally was a bit more readable.

There is nothing wrong with doing a regular function, because you want to think about your future self.

Let's say you come back to the code in 6 months, what will be easier for you to read?

Don't always go to making an arrow function by default, and hopefully throughout this course it will become more clear when you should reach for an arrow function (specifically with arrays and doing maps and reduce and filters).

#### IIFE

The next way to create a function is using an **IIFE** (pronounced **iffy**).

That is an **immediately invoked function expression**.

We will do an example to demonstrate was an IIFE is.

Comment out all the other JavaScript code, add the code below and then refresh `index.html`. ðŸ‘‡

```js
function(){
  console.log('Running the Anon function');
  return `Your are cool`;
}
```

Nothing happens when you refresh `index.html` because it's not allowed to run.
We talked about how you can stick a function in a variable and that is okay.

Another way to run this function is what is called an **immediately invoked functional expression.**

What you can do is wrap that function in a parentheses, _(parentheses always run first in JavaScript)_, and what that will do is return a function value and you can immediately run that function by putting parentheses on the end like so ðŸ‘‡

```js
(function () {
  console.log("Running the Anon function");
  return `Your are cool`;
})();
```

Now, if you refresh the page, you will see the log in the console which means our function expression was immediately invoked. It was immediately run.

What is the benefit of doing something like that?

It used to be very popular before we had modules and block scope.

When we get into scoping, you will learn that a function declares its own scope and its often handy to even declare functions of them, and it will provide us a sheltered space where the variables can't leak inside. We will go over that later in the course.

For now, just know that it's an immediate invoked function.

One last thing is what if the function took an age? You would pass it like so ðŸ‘‡

```js
(function (age) {
  console.log("Running the Anon function");
  return `Your are cool and ${age}`;
})(age);
```

That isn't something you will be using that often, but it does come up when you need to create something like a **closure** _(which will be explained in future video)._

### Methods

Next type of function we will learn about are referred to as **methods**.

A method is simply a function that lives inside of an object.

_(Wes has so far sort of been saying that methods and functions are the same thing and we have a video coming up that focused entirely on creating your own methods that will make that clearer)._

So far Wes has been telling us that `console.log()` is a function.

If we take a look at the function `console.log` in the browser, we will see that he has been lying to us.

`log()` is actually the function that lives inside of `console`, and `console` is actually an object.

If you type `console` into the console and expand it, you will see that there are all kinds of things within it. ðŸ‘‡

![](@attachment/Clipboard_2020-01-30-20-26-46.png)

Scroll down to log, and the little Æ’ you see means that it's actually a function ðŸ‘‰![](@attachment/Clipboard_2020-01-30-20-27-19.png)

So `console` is the object and `log()`, `count()` or any of the other functions listed under the console object are the functions.

We have a special word to describe functions that live inside of an object and we call those **methods**.

So you can actually do something like this.. ðŸ‘‡

```js
const wes = {
  name: "Wes Bos",
  sayHi: function () {
    console.log("Hey wes!");
    return "Hey Wes!";
  },
};
```

Try it in the browser.

First type `wes` and hit enter.
Next, type `wes.sayHi()` and hit Enter.

You should see the following ðŸ‘‡

![](@attachment/Clipboard_2020-01-30-20-30-25.png)

`wes.sayHi()` is a **method**. You make it a property on your object and you set it to a function.

Those functions can also have names, for example sometimes you will see something like this ðŸ‘‡

```js
const wes = {
  name: "Wes Bos",
  sayHi: function sayHi() {
    console.log("Hey wes!");
    return "Hey Wes!";
  },
};
```

Wes doesn't see the point of doing that, but it is technically allowed.

There is also a new shorthand method. ðŸ‘‡

```js
const wes = {
  name: "Wes Bos",
  // Method!
  sayHi: function sayHi() {
    console.log("Hey Wes!");
    return "Hey Wes!";
  },
  //Short hand Method
  yellHi() {
    console.log("HEY WESSSSS");
  },
};
```

If you refresh the browser and type `wes.yellHi()`, it will work.

What we did there is instead of writing `sayHi: function()` _(which does work)_, we can get rid of the `function` keyword and the `;`. bThat makes it into a property, `yellHi()`, which set to the function `yellHi`.

It's just a shorthand way to write methods inside of an object.

There is another way, which is an arrow function. ðŸ‘‡

```js
const wes = {
  name: 'Wes Bos',
  // Method!
  sayHi: function sayHi(){
    console.log('Hey Wes!');
    return 'Hey Wes!';
  },
  //Short hand Method
  yellHi(){
    console.log('HEY WESSSSS');
  }
  //Arrow functino
   whisperHi: () => {
     console.log('hiii wess im a mouse');
   }
};
```

`whisperHi()` is an arrow function that doesn't take any arguments, but it could take in arguments if you wanted.

Those are 3 different ways to do methods and the short hand is the most common way.

### Preview of `this`

The only reason you would do an arrow function is because you don't want to access `this`.

We will go over that in detail when we get to objects but really quickly Wes will show us.

Modify the `sayHi()` method to add `console.log(this);` and run it in the browser ðŸ‘‡

```js
 sayHi: function sayHi(){
    console.log(this);
```

You will see that on the line in our code that we logged, like `50`, the value of `this` has been returned.

![](@attachment/Clipboard_2020-01-30-20-43-26.png)

((`this`)) is equal to the object that it was called against.

That is cool because you could actually do something like this ðŸ‘‡

```js
const wes = {
  name: 'Westopher Bos',
  // Method!
  sayHi: function sayHi(){
    console.log(`Hey ${this.name}`);
    console.log('Hey Wes!');
    return 'Hey Wes!';
  }
```

You would see it immediately fills the value of the name property. ðŸ‘‡

![](@attachment/Clipboard_2020-01-30-20-44-42.png)

That will not work in an arrow function because they take the parent scope of `this`. We will explain that in the future.

### Callback Functions

The final thing Wes wants to talk to us is something called **callback functions**.

So a callback function is just a regular function, but we use that name for something that will happen after something is done.

The easiest way to define a callback function is either when someone clicks something, run this. Or when this amount of time has passed, run this.

Let's look at both of those examples.

#### Callback Example 1 - Click Callback

We will do a click callback.

Go into `index.html` and add a button with a class of `clickMe` and text of "Click Me!" ðŸ‘‡

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title></title>
    <link rel="stylesheet" href="../../base.css" />
  </head>

  <body>
    <button class="clickMe">Click Me!</button>
    <script src="./ways-to-make-a-function.js"></script>
  </body>
</html>
```

Back in the JavaScript file, let's select the element like so ðŸ‘‡
_(we will cover the DOM in more depth later)_

```js
const button = document.querySelector(".clickMe");
console.log(button);
```

Refresh the page and open the console to see that it works.

![](@attachment/Clipboard_2020-01-30-20-57-19.png)

Next, listen for a click on that button as shown below

```js
const button = document.querySelector(".clickMe");
button.addEventListener("click", wes.yellHi());
```

When that click happens, we can pass it to any function that we want. in this case, we chose `sayHi()` from our `wes` object from a previous example.

Now, every time you click it, it will say "HEY WESSSS" ðŸ‘‡

![](@attachment/Clipboard_2020-01-30-20-59-21.png)

What is happening there is that `.addEventListener()` is an **event listener** that we are listening for a click on, and the callback function is `wes.sayHi()`.

It's a function that we give it access to.

Notice that we are not running it there, we are just saying here is the function, when someone clicks the button, please call it.

That is what is referred to as a callback function.

Callback functions can be declared outside of the handler, like so ðŸ‘‡

```js
function handleClick() {
  console.log("Great clicking!!");
}
button.addEventListener("click", handleClick);
```

That tells the browser that when the element with a class of `.clickMe` is pressed, run the `handleClick` function. The other option, which is half as common, is to define the function outside and then pass in the reference to the function.

Another thing you can do is just pass it an anonymous function, as shown below.

```js
button.addEventListener("click", function () {
  console.log("nice Job!");
});
```

![](@attachment/Clipboard_2020-01-30-21-06-26.png)

And it works just fine when you press it.

We have What we have done there is we have passed it an anonymous function as a value directly, and the browser will know to call this function itself. _(There are upsides and downsides of doing it that way which we will get into another time.)_

What you need to know is that a **callback function is a function that gets passed into another function and then it is called by the browser at a later point in time.**

### Timer Callback

The other example we have is a timer callback.

There are a couple way to do timers _(we will go over all of them in the future)_ but the simplest is `setTimeout()`.

```js
setTimeout();
```

It takes two things:

1. a function to call after a certain amount of time
2. a duration in milliseconds (after how long should I run this)

So let's do `1000` milliseconds which is one second later.

```js
setTimeout(wes.yellHi(), 1000);
```

If we refresh the page, after one second, it will log HEY WES.

You can also pass it an anonymous function.

```js
setTimeout(function () {
  console.log("DONE TIME TO EAT");
}, 1000);
```

After a second that will log "DONE TIME TO EAT".

You can pass those as arrow functions as well.

```js
setTimeout(() => {
  console.log("DONE TIME TO EAT");
}, 1000);
```

That will work the same!

---

## 16 - Debugging Tools

There are 2 parts of debugging:

1. there are tools you can use to get info when things go wrong
2. the right mindset to be a good problem solver

This video will focus on the tools.

As you go through the course, anytime we start to hit a roadblock, Wes won't cut it out of the video, he will leave it in and show us his thought process.

We will be working out of the `16 - Debugging` folder which is in the `exercises` directory. Within that folder, there should be two files: `debugging-START.js` and `debugging.html`.

If you open `debugging.html`, you will see that it's just a basic html file where we are loading our base CSS, we have a button that says make me bigger and then a script tag that is loading `debugging.js` which doesn't exist yet.

Make a copy of the `debugging-START.js` file and save it as `debugging.js`.

This file contains a bunch of stuff we haven't learned yet:

- arrays of objects,
- loops,
- functions
- event listeners
- etc.

It doesn't matter that we don't know what all those different things do yet, Wes will explain them later and we will learn how to build our own. This is more so we can test different types of debugging.

### Console Debugging

We will start with console debugging.

There is `console.log()` which is the most common one you'll see. ðŸ‘‡

```js
people.forEach((person, index) => {
  console.log(person.name);
});
```

There is `console.info(person.name)` which usually gives you a little eye and cirlce beside the console output but it doesn't seem to be there right now.

There is `console.error(person.name)`.

That isn't used for throwing or handling errors (we will learn about that), this just changes what the log looks like in the console, as shown below ðŸ‘‡

![](@attachment/Clipboard_2020-01-31-17-46-02.png)

It also gives you a stack trace ðŸ‘‡

![](@attachment/Clipboard_2020-01-31-17-47-21.png)

There is `console.warn()` which is very similar to `console.log()` ðŸ‘‡

![](@attachment/Clipboard_2020-01-31-17-47-38.png)

There is `console.table()`.

Anytime you have a list of objects, and the objects have the same property (meaning the objects all have `name`,`cool`, and `country` properties), `console.table()` will format that into a nice little table.

```js
console.table(people);
```

![](@attachment/Clipboard_2020-01-31-17-49-45.png)

There is `console.count()`.

This is useful if you want to know how many times a function is being run.

If we go into the `doctorize()` function in `debugging.js` and add `console.count('running doctorize');`, and then refresh the html page, every time you type `doctorize('wes');` in the console, the console will log a count.

![](@attachment/Clipboard_2020-01-31-17-52-29.png)

That is useful in a scenario where you aren't sure if a function is running twice, or sometimes you are working with hover elements and it's getting triggered way too often. `console.count()` will show you how many times it's actually running.

You can also pass variables to `console.count()`. To demonstrate that, let's change the example to use backticks, like so ðŸ‘‡

```js
function doctorize(name) {
  console.count(`running Doctorize for ${name}`);
  return `Dr. ${name}`;
}
```

Now if you type in the console `doctorize('wes')`, it will show the count, but if you run `doctorize('snickers');`, it goes back to one.

![](@attachment/Clipboard_2020-01-31-17-57-25.png)

But if you call `doctorize('wes');` again, it maintains that count.

![](@attachment/Clipboard_2020-01-31-17-58-57.png)

`console.count()` is based on what strings you pass it.

Next we have `console.group()`, that can be helpful if you have a bunch of stuff to log.

We will make a function `doALotOfStuff` to demonstrate this.

Comment out all of the example consoles we have gone over so far.

```js
console.group("Doing some stuff");
```

ðŸ‘† Add the code above, and then underneath it, add a few more consoles such as log, warning, error. Then add `console.groupEnd()` and pass it the same string we had passed to `console.group()`, like so ðŸ‘‡

```js
function doALotOfStuff() {
  console.group("Doing some stuff");
  console.log("Im one");
  console.warn("watch out!");
  console.error("hey");
  console.groupEnd("Doing some stuff");
}
```

![](@attachment/Clipboard_2020-01-31-18-15-45.png)

What that does is it groups together all of the logs into a group-able thing, and that can be very helpful.

We will do another example in the `people.forEach()` method.

```js
people.forEach((person, index) => {
  console.group(`${person.name}`);
  console.log(person.country);
  console.log(person.cool);
  console.log("DONE!!");
  console.groupEnd(`${person.name}`);
});
```

![](@attachment/Clipboard_2020-01-31-18-20-52.png)

As you can see, it nicely organizes the people into their separate collapsible section. ðŸ‘†

```js
console.groupCollapse();
```

You can actually also use the `.groupCollapse()` method shown above ðŸ‘† which will by default collapse all the groups, as shown below ðŸ‘‡.

![](@attachment/Clipboard_2020-01-31-18-22-08.png)

Those are the main console methods that Wes uses to debug something.

Comment out all the `console.group()` code.

## The Call Stack and Stack Trace

Next we will talk about something called the **call stack** or the **stack trace**. _The stack trace will tell you which function called what function called what function._

If you scroll down to the function `go`, you will see that it calls `doctorize`, which will first call `greet`.

There is a lot going on in the code.

![](@attachment/Clipboard_2020-02-01-14-03-17.png)

You will notice that inside of `greet()` we have this function that doesn't exist, and that wil cause an error. If we try to run that from the console, you will see an uncaught reference error.

If you expand the error, you should see a few message below, which are often ignored by new developers but are actually very useful in debugging.

If you want to know what went wrong, you have to get good at reading the call stacks. It's pretty simple!

![](@attachment/Clipboard_2020-02-01-14-04-35.png)

In the error log above, the console it letting us know that the error happened at the `greet()` function, which is on line 47 of `debugging.js`. This is where the actual error happened.

That is good, but errors aren't always that easy.

You might need to know where the `greet()` function was called from.

To figure that out, you would go to the next line which tells you that it was was called by `go()` on line 52.

And then it says `at <anonymous>:1:1`. What does that mean?

We are getting that message because we called the function from the console.

That would look different if we actually made another function that called go instead like so ðŸ‘‡

```js
function bootstrap(){
  console.log('starting the app!);
}
```

If you call `bootstrap()` from the console, you will see ðŸ‘‡

![](@attachment/Clipboard_2020-02-01-14-19-44.png)

If you were to modify `debugging.js` to add a call to bootstrap on page load like so: `bootstrap();`, you won't see that anonymous function line in the call stack.

![](@attachment/Clipboard_2020-02-01-14-23-12.png)

Go ahead and comment out the `bootstrap()` call now.

## Grabbing Elements

Next we will learn about the grabbing of elements.

This is a handy tip that Wes' uses often. If you're on a website, and you're inspecting it, and focusing on an element such as this input from Mozilla's website by clicking on it in the element inspector, if you flip over to the console and type `$0`, it will return to you whatever element you had currently selected in the elements tab.

![](@attachment/Clipboard_2020-02-01-14-26-11.png)

![](@attachment/Clipboard_2020-02-01-14-28-02.png)

That is very useful because now you could do something like call `$0.value()` against it, and it will tell you what you have typed inside the input.

![](@attachment/Clipboard_2020-02-01-14-29-12.png)

You might be wondering, what does `0` int the `$0` mean.

It means the last element that was clicked.

If you were to go back to the elements tab, select another element like a button, when you go back to the console `$0` will give you the button element and`$1` will give you the input.

![](@attachment/Clipboard_2020-02-01-14-30-30.png)

You can keep going forever, if you click another element, it will remember the order in which they were clicked.

Another cool thing you do is the use the `$` and `$$` symbol in the console.
You cannot use these things in your code, it only works in the console. Also, if jQuery is loaded on the page, that won't work.

![](@attachment/Clipboard_2020-02-01-14-32-34.png)

ðŸ‘† Those are shorthand selectors for two things we will learn about in a future video about the DOM. Those selectors will allow us to select things based on selectors.

`$('p')` will give us `document.querySelector()`, which will match the first thing that matches the selector passed.

`$$('p')` will match ALL of the elements that match the selectors.

![](@attachment/Clipboard_2020-02-01-14-39-56.png)

In the value returned from `$('p')` you can see it found the first paragraph, and with `$$('p')`, it found all of the `p` elements on the page.

## Breakpoints

Next we will talk about breakpoints.

```js
console.log(person.name);
```

Go into the `people.forEach()` method and delete all the logs that we had commented out within it and add the code above ðŸ‘†

If you refresh the html page, you will see everyone's name logged to the console.

What you can do is, within the `people.forEach()` method, if you want to pause JavaScript from running, you can type `debugger;`, like so ðŸ‘‡

```js
people.forEach((person, index) => {
  debugger;
  console.log(person.name);
});
```

![](@attachment/Clipboard_2020-02-03-17-29-52.png)

That is a statement that only takes into effect when your dev tools are open, and it will pause JavaScript from running and allow us to peer into JavaScript at that very moment.

If you refresh `debugging.html` now, what happens is that we have set what is called a **breakpoint**. When you set a breakpoint, you are telling JavaScript to break execution of code when it reaches that line.

![](@attachment/Clipboard_2020-02-03-17-32-49.png)

This gives you a whole bunch of information as to what happened.

If you hover over it, it will show you what the variables are equal to at this point in time.

![](@attachment/Clipboard_2020-02-03-17-34-11.png)

You can see that the JavaScript has paused and if you go to the console, you will see that nothing has been logged yet.

Flip back to the sources tab.

On the right hand-side of the `Sources` tab, that is where all the different tools for inspecting what is going on reside.

![](@attachment/Clipboard_2020-02-03-17-35-42.png)

We get the call stack, which we learned about earlier.

It will also let us know what the local variables are.

You can expand the collapsed Local section within the Scope section, or hover over a variable to see it's value.

![](@attachment/Clipboard_2020-02-03-17-37-13.png)

There are other sections for breakpoints which we will get to in a second.

![](@attachment/Clipboard_2020-02-03-17-38-09.png)

What is cool is you can click the play button shown above , and then if you flip back to the console, you will see that the name "Wes" has been logged.

What happened there is when the function first ran, it hit the breakpoint and then when we pressed play, it logged the first persons name and then because it's in a loop, it hit the breakpoint again and paused.

Now you can see that the second person is equal to Scott.

![](@attachment/Clipboard_2020-02-03-17-39-21.png)

You can also step over into the next function call like so ðŸ‘‡

![](@attachment/Clipboard_2020-02-03-17-43-28.png)

When you hit play, it will just continue execution of the code until it hits the next breakpoint.

If you click the option beside the play button that says "Step over next function call", it allows you to run the code line by line.

![](@attachment/breakpoint.gif)

When you feel like you are logging too much data in order to see it, or you are logging something quickly so you can see what happened in the past, adding a debugger (it can go anywhere in your JavaScript code) can be very helpful.

It's a handy way to slow things down and peer into what the different pieces of data are.

You can also set breakpoints from the browser as well.

Remove the line of code in `debugger.js` that says `debugger;` and refresh `debugging.html` in the browser.

Open the sources tab.

![](@attachment/Clipboard_2020-02-03-17-50-42.png)

In the sidebar on the left, you can click on your actual JavaScript files that are loaded on the page, and then you can say something like "when someone runs this go() function, I want to put a breakpoint in there"

![](@attachment/Clipboard_2020-02-03-17-55-27.png)

What you do is you click the line number next to the line of code that you would like to pause during.

If you go into the console and type `go()`, you will see that the code pauses itself in the debugger at the line where you set the breakpoint.

_Recap: you can either create the breakpoint by clicking next to the line number in the sources tab, or adding the word `debugger;` anywhere in your JavaScript._

Always make sure you remove those `debugger;` calls from your code once you are finished!

We talked about scope earlier. Scope will allow us to peer into what variables are, we will look at that more in the next video.

The next one is Network Request.

This is useful if you want to see what is being fired off when you load the page. If you go to your networks tab and refresh `debugging.html`, you will see all of the different files that are needed in order for the page to work.

![](@attachment/Clipboard_2020-02-03-18-00-04.png)

This is helpful because you can see when the data is being sent to you.

Wes added a function to `debugging.js` called `fetchDadJoke()`.

What that function will do is go off to an API and grab a random dad joke.

Don't worry about what all the lines of code mean here, we will go over that in future videos. For now, just know that it goes to an external API and grabs a joke.

```js
// A Dad joke fetch
async function fetchDadJoke() {
  const res = await fetch("https://icanhazdadjoke.com/", {
    headers: {
      Accept: "text/plain",
    },
  });
  const joke = await res.text();
  console.log(joke);
  return joke;
}
```

If you were to run the `fetchDadJoke()` function in the console, it will return a dad joke and log it to the console.

If you go back to the network tab, you will see that there is a new item that has been logged.

![](@attachment/Clipboard_2020-02-03-18-03-09.png)

This tells you the information about the request, what actually happened, the raw response and a preview of it. It gives you information such as how long did this request take.

![](@attachment/Clipboard_2020-02-03-18-04-09.png)

For example, if youre website is slow, it will tell you how long the request took, and where the time was spent.

To demonstrate this, go to http://apple.com and inspect the network tab.

You will see that there are 100s of things that are requested. You can also filter out the requests within the network tab such as XHR, which is when they're sending data out about you.

![](@attachment/Clipboard_2020-02-03-18-06-25.png)

Next we will go over break on attribute. Wes doesn't use this one often, but it can be useful.

On `debugging.html` there is a button that says "Make me bigger".

![](@attachment/Clipboard_2020-02-03-18-08-59.png)

When you click it, it gets bigger.

If you go to your elements, you will see that the font-size is just being bumped up every time the button is pressed.

If you don't know where the JavaScript is that is making that button bigger, you can go into you button in the elements tab of dev tools and select _Break on > Attribute Modifications_.

![](@attachment/Clipboard_2020-02-03-18-10-14.png)

This is just another way of adding a breakpoint.

There is also something called **subtree modifications** which is what it is referred to when somebody adds a div for example.

There is also something called **node removal** which is when someone removes an element or text from something.

We will just focus on attribute modifications.

Set the breakpoint on attribute modification and now when we click the button, the breakpoint should be triggered and bring us to the sources tab which will show you where that attribute is being modified from.

![](@attachment/attribute-breakpoint.gif)

That is very useful when you get thrown into a random code base where you don't really know what is going on.

Finally, if you go to the sources tab again, you will see that there are other things on the right hand side.

![](@attachment/Clipboard_2020-02-03-18-17-49.png)

You can throw Event Listener breakpoints, such as mouse click. ðŸ‘‡

![](@attachment/Clipboard_2020-02-03-18-18-28.png)

If you add that breakpoint, now when you click on the button, it will throw a debugger breakpoint for you.

There are also XHR breakpoints:

![](@attachment/Clipboard_2020-02-03-18-19-34.png)

If you click `Any XHR or fetch`, what that will do is anytime a fetch request is made, anytime someone goes off to an external API, the code will break execution.

To test this you can set the breakpoint option and then go into the console and try typing `fetchDadJoke()`.

You will see that it pauses in the debugger where the fetch request is made and we can actually step through it.

Wes would estimate that around 98% of the debugging that he does is done using console.log, breakpoints and network requests.

He will turn to the other types of debugging tools available typically in severe edge cases where he is stumped.
