---
attachments: [Clipboard_2020-01-28-16-43-12 (2).png, Clipboard_2020-01-28-16-47-39 (2).png, Clipboard_2020-01-28-16-48-49 (2).png, Clipboard_2020-01-28-17-00-34.png, Clipboard_2020-01-28-17-05-22.png, Clipboard_2020-01-28-17-12-10.png, Clipboard_2020-01-28-17-15-30.png, Clipboard_2020-01-28-17-16-18.png, Clipboard_2020-01-28-17-17-04.png, Clipboard_2020-01-28-17-18-49.png, Clipboard_2020-01-28-17-25-44.png, Clipboard_2020-01-28-17-27-44.png, Clipboard_2020-01-28-17-31-06.png, Clipboard_2020-01-28-17-35-06.png, Clipboard_2020-01-28-17-35-44.png, Clipboard_2020-01-28-17-41-21.png, Clipboard_2020-01-28-19-48-01.png, Clipboard_2020-01-28-19-54-21.png, Clipboard_2020-01-28-19-59-14.png, Clipboard_2020-01-28-20-05-33.png, Clipboard_2020-01-28-22-28-03.png, Clipboard_2020-01-28-22-28-19.png, Clipboard_2020-01-29-15-31-21.png, Clipboard_2020-01-29-15-31-32.png, Clipboard_2020-01-29-15-32-16.png, Clipboard_2020-01-29-15-50-59.png, Clipboard_2020-01-29-15-55-38.png, Clipboard_2020-01-29-15-57-14.png, Clipboard_2020-01-29-16-43-59.png, Clipboard_2020-01-29-16-44-48.png, Clipboard_2020-01-29-16-45-24.png, Clipboard_2020-01-29-16-50-48.png, Clipboard_2020-01-29-16-55-56.png, Clipboard_2020-01-29-16-57-30.png, Clipboard_2020-01-29-17-00-53.png, Clipboard_2020-01-29-17-01-04.png, Clipboard_2020-01-29-18-48-01.png, Clipboard_2020-01-29-18-48-13.png, Clipboard_2020-01-29-18-51-05.png, Clipboard_2020-01-29-18-51-45.png, Clipboard_2020-01-30-17-50-07.png, Clipboard_2020-01-30-17-51-04.png, Clipboard_2020-01-30-17-52-26.png, Clipboard_2020-01-30-19-48-27.png, Clipboard_2020-01-30-19-58-43.png, Clipboard_2020-01-30-20-06-08.png, Clipboard_2020-01-30-20-07-35.png, Clipboard_2020-01-30-20-25-18.png, Clipboard_2020-01-30-20-26-46.png, Clipboard_2020-01-30-20-27-19.png, Clipboard_2020-01-30-20-30-25.png, Clipboard_2020-01-30-20-43-26.png, Clipboard_2020-01-30-20-44-42.png, Clipboard_2020-01-30-20-57-19.png, Clipboard_2020-01-30-20-59-21.png, Clipboard_2020-01-30-21-06-26.png, Clipboard_2020-01-31-17-36-06.png, Clipboard_2020-01-31-17-36-25.png, Clipboard_2020-01-31-17-45-50.png, Clipboard_2020-01-31-17-46-02.png, Clipboard_2020-01-31-17-47-21.png, Clipboard_2020-01-31-17-47-38.png, Clipboard_2020-01-31-17-49-45.png, Clipboard_2020-01-31-17-52-29.png, Clipboard_2020-01-31-17-55-36.png, Clipboard_2020-01-31-17-57-25.png, Clipboard_2020-01-31-17-58-57.png, Clipboard_2020-01-31-18-15-45.png, Clipboard_2020-01-31-18-20-52.png, Clipboard_2020-01-31-18-22-08.png, Clipboard_2020-02-01-14-02-53.png, Clipboard_2020-02-01-14-03-17.png, Clipboard_2020-02-01-14-04-35.png, Clipboard_2020-02-01-14-19-44.png, Clipboard_2020-02-01-14-23-12.png, Clipboard_2020-02-01-14-26-11.png, Clipboard_2020-02-01-14-28-02.png, Clipboard_2020-02-01-14-29-12.png, Clipboard_2020-02-01-14-30-30.png, Clipboard_2020-02-01-14-32-34.png, Clipboard_2020-02-01-14-39-56.png, Clipboard_2020-02-03-17-29-52.png, Clipboard_2020-02-03-17-30-52.png, Clipboard_2020-02-03-17-31-47.png, Clipboard_2020-02-03-17-32-49.png, Clipboard_2020-02-03-17-34-11.png, Clipboard_2020-02-03-17-35-42.png, Clipboard_2020-02-03-17-37-13.png, Clipboard_2020-02-03-17-38-09.png, Clipboard_2020-02-03-17-39-21.png, Clipboard_2020-02-03-17-43-28.png, Clipboard_2020-02-03-17-47-27.png, Clipboard_2020-02-03-17-50-42.png, Clipboard_2020-02-03-17-55-27.png, Clipboard_2020-02-03-18-00-04.png, Clipboard_2020-02-03-18-03-09.png, Clipboard_2020-02-03-18-04-02.png, Clipboard_2020-02-03-18-04-09.png, Clipboard_2020-02-03-18-06-25.png, Clipboard_2020-02-03-18-08-26.png, Clipboard_2020-02-03-18-08-59.png, Clipboard_2020-02-03-18-10-14.png, Clipboard_2020-02-03-18-17-49.png, Clipboard_2020-02-03-18-18-28.png, Clipboard_2020-02-03-18-19-34.png, Clipboard_2020-07-21-17-33-20.png, Clipboard_2020-07-21-17-54-27.png, Clipboard_2020-07-21-19-47-57.png]
title: 'Module 2: Functions'
created: '2020-01-28T21:27:12.651Z'
modified: '2020-07-21T23:54:18.473Z'
---

# Module 2: Functions

## 12 - Functions - Built in

These videos are going to be about functions. We will get a good primer on what functions are, the core concepts, and an overview of the types of functions that you can write. 

It will not be exhaustive, because there is so much more we need to learn in order to take advantage of functions. The rest of the course is going to be using functions, since they are like types, a fundamental building block of javascript and we will get good at functions because we will be writing them throughout this entire course.

So, functions, what are they?

They allow us to group together sets of statements. 

As a refresher from previous videos, these are all statements ðŸ‘‡

![](@attachment/Clipboard_2020-01-28-16-43-12.png)

If you wanted to group all those statements together _(generally they are related to each other and generally they produce some sort of output)_, you could group them together inside of a function. 

Functions can take in data, those are known as **arguments** _(we will discuss the difference between arguments and parameters shortly)_.  When you pass data to a function, it is known as an argument. 

Functions perform some work (a statement), and sometimes they also return a value.

Let's look at an example in the console using `Math.max()` _(this is actually a method, and we will explain the difference between a function and a method shortly, it is not much)_. 

If you run it in the console, it returns negative infinity. 

![](@attachment/Clipboard_2020-01-28-16-47-39.png)

What we want to do is pass it some data, and it should return to us the maximum value. 

For example, let's pass two numbers, 10 and 12. It will return to us the highest number (which is 12).

![](@attachment/Clipboard_2020-01-28-16-48-49.png)

Now what is going on there? 

`Math.max(10, 12)` is a javascript statement. The values `10` and `12` that we are passing into the function are called **arguments**. 

If you are passing multiple values to a function, you need to separate each value with a comma and it's  best practice to include a space between each. 

To repeat, the data that you pass to a function, the data that you give to a function in order for it to run is called an argument. 

Sometimes, functions will return to you some data that is generally the answer or the computed output based on what you passed in. 

For example, `Math.floor(2.4444)` will return `2`

Here we are passing one argument of `2.4444` and it returns to us the floor of that value which is `2`. 

![](@attachment/Clipboard_2020-01-28-17-00-34.png)

### Built-in Functions

There are a whole bunch of built-in functions in javascript, whether you are using it in the browser or with node. 

They come with all of these built in things, and we have already been using them because there is no way around it. The one that we have used the most so far is `console.log()`. 

For example if you `console.log('hey`)`, it will return hey. 

Interestingly enough, it also returns undefined. 

![](@attachment/Clipboard_2020-01-28-17-05-22.png) 

That is because the console.log function logs to the console, it does not return a value. Not all functions are meant to return a value, sometimes they just go off and do things without returning a value.

_Tip: You can tell in the console if something is a return or a statement by the `>` and `<.` arrows next to the line in the console. `>` indicates that it's a statement and `<.` indicates that it's the response to the statement._

![](@attachment/Clipboard_2020-01-28-17-12-10.png)

Some other built in functions we can use are ðŸ‘‡

`parseFloat()` which takes in a string and returns a number, it switches the type. For example ðŸ‘‡

```js
parseFloat("20.34543543")
```

![](@attachment/Clipboard_2020-01-28-17-15-30.png)

`parseInt()` takes in a string and returns a number without a decimal. For example ðŸ‘‡

```js
parseInt("20.3243423")
```
![](@attachment/Clipboard_2020-01-28-17-16-18.png)

We looked at `Math.round()`, `Math.floor()`, `Math.ceil()` already in previous lesson.

If you type `Date.now()` in the console it will return something like the following ðŸ‘‡

![](@attachment/Clipboard_2020-01-28-17-17-04.png)

`Date.now()` is a function that does not take in any arguments.  What it returns to us is the number of miliseconds since January 1 1970. 

If you go to https://epoch.now.sh, it's a tool that you can use to convert the milisecond value to a datetime. You can also do the opposite -- pick some date and time in the future and then it will return the milisecond value. 

![](@attachment/Clipboard_2020-01-28-17-18-49.png)

We will go deeper into dates in future videos. 

We also have functions that will work with something called the **DOM**, which are the HTML elements that are on the page. 

Create a new file called `functions.html`, and use the html base snippet. 

Add a paragraph tag inside of the body that says "hey, how ya doin?" and then add an empty script tag below. 

Open that up in the browser. ðŸ‘‡

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Functions!!</title>
    <link rel="stylesheet" href="../base.css" />
  </head>

  <body>
    <p>Hey How ya doin?</p>
    <script>
    </script>
  </body>
</html>
```

In the script section of `functions.html`, add the following code. that will run a function called `document.querySelector()`, to which we are passing a **selector** `p`. This built in function will find something that matches that selector and puts it into a variable, and we will log that variable.

```html
<script>
  const p = document.querySelector("p");
  console.log(p);
</script>
```

![](@attachment/Clipboard_2020-01-28-17-25-44.png)

There are a lot of other functions built in, some are mobile specific like `navigator.vibrate()`. 

![](@attachment/Clipboard_2020-01-28-17-27-44.png)

Another useful thing is if you are not sure what arguments a function should take, you can refer to the Mozilla developer docs, in order to see what is going on. 

In google, type "Navigator.vibrate()". Usually you will need to look for the Mozilla developer _(a tip is to include `mdn` at the end of your search so the Mozilla docs float to the top)._

The docs should explain what the method is, how it can be used, and what it returns. 

![](@attachment/Clipboard_2020-01-28-17-31-06.png)

Let's look at a couple of more. 

Clear the console. 

In `functions.html`, add a lot of text, such as a few paragraphs of Lorem Ipsum.

_(Wes is using the Emmet extension for VS Code which allows him to type `lorem400` and hit tab to expand 500 words of lorem ipsum. You can manually search for a Lorem Ipsum generator online if do not have the Emmet extension.)_

Now if you refresh `functions.html` you will see a lot of text on the page. 

![](@attachment/Clipboard_2020-01-28-17-35-44.png)

Add enough text so you can scroll on `functions.html`. 

Now you should be able to type in the console `window.scrollTo(0, 600)`, and that should cause your window to scroll down 600 pixels. 

If we search for `scrollTo` on Mozilla docs, it says it accepts argumenst of a x and y coordinate, or you can pass it an options object. 

The docs say that 
>options is a ScrollToOptions dictionary

**Dictionary** is a word we use in javascript to represent an object, it's an object that has a number of set properties on it. 

![](@attachment/Clipboard_2020-01-28-17-41-21.png)

##### Example #1 ðŸ‘‡

```js
window.scrollTo(0, 1000);
```

Example #2 ðŸ‘‡

```js
window.scrollTo({
  top: 100,
  left: 100,
  behavior: 'smooth'
});
```

In the first example, we are passing two numbers but it's also an option to pass an object which has properties inside of it like `top`, `left`, and `behavior`. 

Try typing into the console the following ðŸ‘‡

```js
scrollTo({top:500, left:0, behavior: 'smooth})
```

That page should cause the page to scroll down 500 pixels. 

![](@attachment/scrollTo.gif)

`scrollTo` is an example of a function that does return anything, instead it just goes off and does some work for us. 

---

## 13 - Functions - Custom

In this video we will get into making our own custom functions. 

A function can do anything, and the real power of Javascript comes when you define your own functions. 

Functions group together a set of instructions, often taking in values (we talked about **arguments** earlier), doing some work and then returning value or set of values back to what requested it. 

For this lesson, you need to make a new folder `/custom-functions` inside of `/playground`. Within that folder, create two files `index.html` and `cf.js`.  Add a log of "it works!" in the js file, and add the HTML base snippet to the HTML page. 

We will need to modify the `base.css` path because we made a folder so the path should now be `../../base.css` _(because we have to go up two levels to get to it)_. 

Right before the closing body tag, add a script source tag like so ðŸ‘‡ and you should see "It works!" in the console. 

```html
<script src="./cf.js">
```

![](@attachment/Clipboard_2020-07-21-17-33-20.png) 

In this lesson, we are going to create a function called "Calculate Bill". 

You can think of "Calculate Bill" (said in southern american accent) as a western gentlemen who is very good at going to restaurants and calculating what the bill would be regarding what the bill was, how much tip was, how much tax is. That is what our function will be responsible for doing. 

There are going to be a few buzzwords as we go through, which we will explain as we go, starting . 

The first one is that **functions are created or defined**, and they are later **called**.

When you make a function, when you author what it does, that is called a **function definition**. 

Later on, when you want to **run** that function, that is called **calling** or **running** of a function. 

### Defining a Function

There are a few ways to define a function. We are going to go over all the different approaches in the next videos but for now, we will go over the basic. 

First you type `function` and then the name of the function. Function naming follows the exact same rules as variable naming which we went over in a previous video. 

We are going to call it `calculateBill` ðŸ‘‡

```js
function calculateBill(){
//this is a function body
}
```

What we have done is defined it, given it parenthesis and then you open and close a function block.  
Anything that goes inside the function block is called the **function body**, and is part of the function. 

In the function body, add ðŸ‘‡

```js
console.log('Running Calculate Bill!!!');
```

Open `index.html` and in the browser and open the console. Try typing `calculateBill` in the console and hitting enter. 

![](@attachment/Clipboard_2020-01-28-19-48-01.png)

A function works just like a variable in that you can call them by the name of it. However, when you put just the name of the function, you see the entire code, as shown ðŸ‘† above. 

Now if we want to run the function we would have to enter into the console `calculateBill()`, which will log `Running Calculate Bill!!!!` in the console. 

Add the following to `cf.js` to run the function right from our Javascript. ðŸ‘‡

```js
// Function Definition
function calculateBill() {
  // this is the function body
  console.log('Running Calculate Bill!!');
}

//Function Call or **Run**
calculateBill();
```

### Returning Values 

When we called `calculateBill()` in the console, it returned undefined. 

![](@attachment/Clipboard_2020-01-28-19-54-21.png)

It does the work we asked it to do, and then it returns undefined. Often, functions will do a bunch of work and then return to you the result. 

What we are going to do in our function is we will take in the following arguments,  and it will return to us the total value: 
 - how much the dinner was
 - the tax rate 
 - how much you want to tip

The way that works is we will assume the meal is 100 dollars, and we will multiply it by 1.13 because in Ontario the tax rate is 13%. 

Now we can log the total value to the console. 

```js
// Function Definition
function calculateBill() {
  // this is the function body
  console.log('Running Calculate Bill!!');
  const total = 100 * 1.13;
  console.log(total);
}

//Function Call or **Run**
calculateBill();
```

![](@attachment/Clipboard_2020-01-28-19-59-14.png)

_(ðŸ‘† This is a perfect example of the issue with floating point numbers mentioned in a previous video)_

You might be thinking "oh, now I have this nice total variable which I can just quickly access". However, if you type `total` in the console, it will return undefined. 

Try that by adding the following code to `cj.fg` below the `calculateBill` function definition, refresh the page and look at the error in the console. 

```js
console.log('total')
```

You should see an error 
>total is not defined

![](@attachment/Clipboard_2020-07-21-17-54-27.png) 
 
In VSCode, you may notice that ESLint is yelling at us aswell that total is not defined. 

This is something that we will get into called **scope**. 

Variables that are created inside of a function are only available within that function, which is called block scoping _(we will cover block in more detail in the future)_. It is not available outside of it. 

So how do we store the result of the calculation so we can access it using a variable? With returning! 

When we called `calculateBill()` earlier, we got undefined returned in the console. To fix that, we need to return total. 

`return` is a keyword in Javascript. 

```js
  const total = 100 * 1.13;
  console.log(total);
  return total;
}

//Function Call or **Run**
calculateBill();
```
Now when you call it in the console, you will see it returns the value. 

![](@attachment/Clipboard_2020-01-28-20-05-33.png)

### Storing a Value Returned from A Function

How can we store that value? 

The total variable is still not available to us. That is because we need to **capture** (another buzz word) the result of the function or capture the returned value of the function into a variable. 

Modify the line of javascript with `calculateBill()` like so ðŸ‘‡

```js
const myTotal = calculateBill();
console.log(myTotal);
```

In the console, you can now access the variable `myTotal`. Modify the log like so ðŸ‘‡

```js
console.log($`Your total is $${myTotal}`);
```
That will print out the value and message in the console. 

You may be wondering why we have two variables to hold the same value, `total` within `calculateBill()` and `myTotal` below the function.

The reason is that `total` variable is a **temporary variable**. 

Since `total` is created inside of the function, it is only ever available inside of `calculateBill` and when the function is done running, that variable is **cleaned up** (or what is called **garbage collected** in Javascript and it's no longer needed).  

If you ever want to capture the value returned from `calculateBill()`, you have to stick it into a variable before you can go ahead and display it. 

Another cool thing you can do with **interpolation** strings is you can actually run the function from within the log statement. 

Javascript is going to run the function first, and then whatever the return result is it will immediately be interpolated into that string.

```js
console.log(`Your total is $${calculateBill()}`);
```

---

## 14 - Functions - Parameters and Arguments

This video will focus on **arguments** and **parameters**. 

In the `calculateBill()` function from the previous video, we hardcoded the tax amount. 

A best practice in Javascript is to keep your code **DRY**, which stands for **Don't Repeat Yourself**. 

`calculateBill` would not be useful if it could only calculate the value assuming the bill is $100 and a 15% tax  rate, so we need to modify those hardcoded values.

To solve that, above the calculateBill function, we can declare variables for the bill total and taxRate. 

Modify the code like so ðŸ‘‡

```js
const bill = 100;
const taxRate = 0.13;

function calculateBill(){
  console.log('Running calculate bill!!');
  const total = bill * taxRate;
  return total;
}
```

This will work, but that is not the best way to do it. Why? 

`calculateBill` is relying on something called **global variables** _(which will be explained in future videos)_. 

For right now, what you need to know is that `calculateBill` needs needs some data. When it is not passed data, it is instead reaching outside of the function in order to look up that data in a higher **scope**.
 
That is not great practice _(reaching outside of a function in order to get your data)_. 

In `cf.js`, remove the last console.log and add the following ðŸ‘‡

```js
const myTotal = calculateBill();
const myTotal2 = calculateBill();
console.log(myTotal, myTotal2);
```

_TIP: You can log as many pieces of data as you want by separating the values with commas like in the example above._

The log will return the same value: 

>$100.13.

What if we wanted a different value? Could we do something like this?  ðŸ‘‡

```js
const myTotal = calculateBill();
bill = 200;
const myTotal2 = calculateBill();
console.log(myTotal, myTotal2);
 ```

_(Note: you need to change the `bill` variable that is declared in `cf.js` to a `let` instead of a const so we can reassign it)_

If you refresh it, now it works. 

However, we have been changing the variable by modifying out code each time we want to run it with different values. This is bad practice and it is how you get very brittle applications.

What we want to do is instead of reaching out, we will pass the data that we need into our functions.

First let's do a bit of cleanup. Get rid of the `let bill` and `const taxRate` variables.  Get rid of lines of code where we are reassigning variables and declaring myTotal2 (`bill = 200; const myTotal2 = calculateBill()`) and the last log. 

You should end up with the following code ðŸ‘‡

```js
// Function Definition
function calculateBill() {
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = bill * 1 + taxRate;
  return total;
}

const myTotal = calculateBill();
```
Now we want to take the variables bill and tax rate and we want to make them into something called **parameters** or **params** for your function.

When you define your function, you add params which let's you know that the function expects to be passed some data. Wes likes to think of params as placeholders. 
```js
function calculateBill(billAmount, taxRate){
```

Inside of the function body, we will have access to the two variables that were passed:
- `billAmount` 
- `taxRate`

It's can be confusing because there is no "creation of the param variables", but Wes will do his best to explain it.

```js
// Function Definition
function calculateBill(billAmount, taxRate) {
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = billAmount * (1 + taxRate);
  return total;
}

const myTotal = calculateBill(100, 0.13);
console.log(myTotal);
```

That will give you $100.13. 

But now we are able to make a `myTotal2` really quickly ðŸ‘‡

```js
const myTotal = calculateBill(100, 0.15);
const myTotal2 = calculateBill(200, 0.13);
console.log(myTotal, myTotal2);
```

It works without having to reassign because when you define a function, you can place parameters. P = placeholder is one way to remember it. 

When you call the function, you pass it arguments. 

Here is a quick cheatsheet Wes has put together that explains the parts of a function. 

![](@attachment/Clipboard_2020-01-28-22-28-19.png)

When we define the function name, we put what are called **parameters**. Parameters can be thought of as placeholders (we will talk about **default values** for parameters shortly). 

When you **call**, **run** or **invoke** (all 3 mean the same thing), and you actually pass it the data, that will take place of the variables (for example `meal` will be `100` and `taxRate` will be `10.13`), those will be called **arguments**. 

People incorrectly use those terms interchangably. One way to remember is that _parameters are placeholders_. The actual values that you pass in when calling a function are what are called **arguments**. 

Bringing it back to `const myTotal = calculateBill(100,0.13)`, here we are running the function and as arguments we are passing straightaway numbers. However, the values that get passed into a function can be in a variable as well.  This is a common thing people get hung up on when learning how functions work is how they sort of get renamed. 

Let's take a look at code we wrote for `calculateBill()`.

The data gets passed into the function, and those variables are only available inside of the `calculateBill` function. They will be what is called **scoped to the function**, which means only available inside of the function.

If we add a log within calculateBill like so ðŸ‘‡

```js
// Function Definition
function calculateBill(billAmount, taxRate) {
  console.log(billAmount, taxRate);
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = billAmount * (1 + taxRate);
  return total;
}
const myTotal = calculateBill(100, 0.15);
```

![](@attachment/Clipboard_2020-01-29-15-31-32.png)

We can run that function from the console but pass it different values for the arguments, it will console log the values of the arguments that we passed, like so ðŸ‘‡

![](@attachment/Clipboard_2020-01-29-15-32-16.png)

Why? 

Because Javascript will take whatever you write as an argument, and then when you call the function it will make it sort of temporarily available to you via the names that you put in your parameters. 

What gets a little bit confusing to people is if we declare two variables before we call the function like so ðŸ‘‡

```js
const wesTotal = 500;
const wesTaxRate = 0.3;
const myTotal = calculateBill(100, 0.15);
```

We can actually pass those variables into the function like this ðŸ‘‡

```js
const wesTotal = 500;
const wesTaxRate = 0.3;
const myTotal = calculateBill(wesTotal, wesTaxRate);
```

Now the big confusion is, if they are variables outside of the function, and we pass them into the function, when it's called inside of the function, is the first parameter called `billAmount` or is it called `wesTotal`? 

Will it even work if you pass in a variable that does not have the same name as the parameter?  Try refreshing `index.html` in the browser.

_**You should see it works just fine!**_

To review, when you run a function in Javascript, what happens is Javascript takes in whatever you have pass it, whether you have passed it that value directly _(as a number or string for example)_, or if you pass it in via reference _(meaning that you just passed a reference to a variable which in turn will hold a value)_. 

At the end of the day we are still passing values, whether you pass it directly or whether you pass it a reference to a variable that holds a value.  Javascript doesn't care about how you are passing them in, whether as a value directly or as a variable. 

In this function, Javascript will take whatever was passed in the first argument and make it into a temporary variable `billAmount` that is available inside of the confines of the curly brackets.

When the function is running, it does not care about anything else that is going outside of this function. It just knows it's doing it's job, it's been pased in the two little pieces of data that it needs, it does the math and returns it's value from within the function.
 
When values get passed into a function, they sort of get renamed into whatever it is that you have defined your function parameters as.

### Another Example

Let's do another example!

Comment out the code `const myTotal = calculateBill...`. 

Add the following function to your code, which just returns hello and which we will pass in someone's first name ðŸ‘‡

```js
function sayHiTo(){
 return `Hello ${firstName}`; 
}
const greeting = sayHiTo();
console.log(greeting);
```

Run the code as is, even though it will break, to see why.  In the console you should see an reference error in the console. 

![](@attachment/Clipboard_2020-01-29-15-50-59.png)

What happens is this function, first it looks inside of it's own function scope, and it will look for a variable `firstName` that has been passed in. If there is not, it will start to do is go up to a high level of scope and look there. 

Let's say there was a firstName variable like so ðŸ‘‡

```js
const firstName = 'wes';
function sayHiTo(){
 return `Hello ${firstName}`; 
}
const greeting = sayHiTo();
console.log(greeting);
```

That would work, because the function will reach outside for that data if nothing is found within the scope of that function. 

What we want to do is modify the function definition to set it to take in one parameter (`firstName`). And then when we run the function, we actually have to pass it a string (we will use `Wes`), and then we will have our greeting.

```js
const firstName = 'wes';
function sayHiTo(firstName){
 return `Hello ${firstName}`; 
}
const greeting = sayHiTo('Wes');
console.log(greeting);
```

This makes the function nice and reusable, and we can use it to print out any first name like so ðŸ‘‡
![](@attachment/Clipboard_2020-01-29-15-55-38.png)

As long as we pass in an argument (in this case "Wes"), it is going to have a variable inside of that function that is referenced to whateer the person has passed in. 

If we don't run it with anything, you will see... ðŸ‘‡

![](@attachment/Clipboard_2020-01-29-15-57-14.png)  

The reason that happens is when a function runs, it will create the variable for us (`firstName`) and set it to whatever was passed in. 

But if it creates a variable and someone doesn't pass in anything, then it will just be set to undefined which is exactly how variables work. 


### Even More Example

Now let's go over a few more examples. 

Let's go back to passing expressions. For this example we will go back to `calculateBill`.  

```js
// const greeting = sayHiTo('Wes');
// console.log(greeting);
const myTotal3 = calculateBill(100, 0.15);
```

We know the code above works but what if instead we do ðŸ‘‡

```js
const myTotal3 = calculateBill(20 + 20 + 30 + 20, 0.15);
```

Is that going to work? 

If you load `index.html` in the broswer you will see `103.4999999999`. 

_(If you followed Wes too closely, you may have gotten the value of 90.5. If that is the case, the line of code that calculates the total within `calculateBill`. It should be `const total = billAmount * ( 1 + taxRate);`. This is because of bedmas, we need the paranthesis)._

That works. 

Why? 

Because the only thing that a function can take in is a value, and whether you pass that value directly, as in a number, whether you pass that value in as a variable which holds a value, that works, and then you can also pass in expressions. 

In this example we are not actually passing an expression, we are actually running an expression and that will first run (`20 + 20 + 30 + 20`) and add it up to $90, and then we pass that raw value of 90. 

It is absolutely fine to do something that like, in fact it is pretty common. 

You can even mix and match. 

Let's say we have a variable `const kait = 100;` and then we want to add another $50 ontop of that.  You can do something like.. 

```js
const kait = 100;
const myTotal3 = calculateBill(kait + 50, 0.15);
```

It still works, even though we are mixing and matching. 

Let's remove the `myTotal3` example, and do another example where we pass functions as arguments.

Make a function `doctorize` which will take in a `name` argument and return the name with "Dr." in front like so ðŸ‘‡

```js
function doctorize(name){
  return `Dr. ${name}`;
}
```

And we will make another function called `yell` that also takes in a name and returns "HEY" with the variable name uppercased like so ðŸ‘‡

``` js
function yell(name){
  return `HEY ${name.toUpperCase()}`;
}
```

You might have noticed that both functions are using the variable `name`.

While it's not okay to reuse variables in the same scope multiple time, it is okay to reuse parameters. 

Why?  Because when arguments are passed in, the parameters are only available within that function so you will never run into a collision where the name that you pass into one function is going to overwrite it in the other function. That will not happen because _parameters are scoped to the confines of their own functions._

The `name` parameter that is used in the `doctorize()` method will never collide with the variable within the `yell()` method. 

Let's go ahead and run it in the console. ðŸ‘‡

![](@attachment/Clipboard_2020-01-29-16-43-59.png)

Let's pass the output of `doctorize()` into `yell` by typing the following into the console ðŸ‘‡

```js
yell(doctorize('wes))
```

![](@attachment/Clipboard_2020-01-29-16-44-48.png)

How that works is:
- brackets go first. anything in between the yell paranthesis `yell()` the code says "okay, I need to first run this function first" , and hopefully that returns a value (which it does, it returns Dr. + the value of the `name` argument passed)
- then the value that is returned from `doctorize` immediately gets passed into `yell` as an argument and then that will in turn return "Hey  Dr. Wes". 

So to recap -- another way we can pass a value to a function that is the output of a function, because that is just a value at the end of the day and you can run that directly like demonstrated here. 

**Default Values**

Now, let's talk about **default values**. 

If we were to take our `yell` function and instead of passing it "Wes", we do not pass an argument, it will error out. 

![](@attachment/Clipboard_2020-01-29-16-50-48.png)

What is happening is that the `toUpperCase()` function (it's technically a method), it's trying to run it against something that didn't get passed in. This means that is someone forgets to pass a value to the `yell` function, our code will break. 

What we can do is we can set something called **defaults**. When you define your function, inside of your function definition, you can set a default by saying name is equal to 'Silly Goose', as shown below.

```js
function yell(name = 'Sily Goose'){
  return `HEY ${name.toUpperCase()}`;
}
```

If you run it and pass an argument, it will still work. 

However when you run it without an argument, the function will no longer error out and instead will fall back to the default value for the parameter and output `HEY SILLY GOOSE`. 

So as you define your function, you can specify if someone does not pass this paramenter `name`, use the default. 

Let's go back to our `calculateBill` function. 

You may be thinking that it's a bit silly to have to pass in the the tax rate every single time.  We will use a default value to set a default tax rate of 0.13, by modifying the function like so  ðŸ‘‡

```js
// Function Definition
function calculateBill(billAmount, taxRate = 0.13) {
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = billAmount * (1 + taxRate);
  return total;
}
```

What that allows us to do is call `calculateBill(100)` and only pass the value for the `billAmount`. 

![](@attachment/Clipboard_2020-01-29-16-55-56.png)

Wes often likes to set default values when he is creating functions. Even just adding a default value for a string variable of an empty string. 

```js
function yell(name = ''){
  return `HEY ${name.toUpperCase()}`;
}
```

That will make sure the function doesn't error out, it just won't show a name like so ðŸ‘‡

![](@attachment/Clipboard_2020-01-29-16-57-30.png)

That is just a safeguard. 

Let's take it one step futher and modify `calculateBill` to also take in a tip rate. 

Add another argument with a default value `tipRate = 0.15` ðŸ‘‡

```js
// Function Definition
function calculateBill(billAmount, taxRate = 0.13, tipRate = 0.15) {
  // this is the function body
  console.log("Running Calculate Bill!!");
  const total = billAmount * (1 + taxRate);
  return total;
}
```

Now we will change the way we calculate total like so ðŸ‘‡

```js
const total = billAmount + (billAmount * taxRate) + (billAmount * tipRate);
```

You may notice that as you save the file, Prettier will remove the paranthesis if they are not needed (the BEDMAS rules are not needed here)

BEFORE SAVING   ðŸ‘‰  ![](@attachment/Clipboard_2020-01-29-17-00-53.png) 

AFTER SAVING WITH PRETTIER ðŸ‘‰ ![](@attachment/Clipboard_2020-01-29-17-01-04.png)

If we run `calculateBill` and pass it 100 dollars, it will return 128.

### How to Fall Back on Default for Only One Parameter

A gotcha that happens here is _what if you want to use the default tax rate but not the default tipRate?_

```js
const myBill4 = calculateBill(100, ,0.2);
```

If you try to just leave the argument empty and use two commas like shown above ðŸ‘†, it will break. 

![](@attachment/Clipboard_2020-07-21-19-47-57.png)

ðŸ‘† The error is complaining about an unexpected token `,`. 

So the only thing that you can pass into a function to cause it to use the default is **undefined**. A function will only ever fall back to the defaults if nothing is passed. 

Remember when a variable is not set to anyting, it's value is `undefined`. So you cannot go ahead and pass zero here and expect it to false back to the deault. 

```js
const myBill4 = calculateBill(100, undefined, 0.2);
``` 

You have to actually pass it `undefined`, ðŸ‘† as shown above, and it will work as we intended. 

It's very infrequently that you have to pass `undefined` like that but it's worth knowing how a function decides whether or not to fall back on a default. 

It has nothing to do with **truthy** or **falsey** which we will be learning soon. 

---

## 15 - Different Ways to Declare Functions

One thing you're goin to hear a lot when you're getting into javascript is that javascript functions are "First class citizens". 

That means javascript functions  are values in themselves, they can be stored in variables and passed into other functions. 

What is a value in javascript?  We know that in the examples below `true` and `100` are values.
```
const age = 100;
const cool = true;
```
Those are values that are numbers, or strings or booleans.
What is cool about javascript is that functions can be passed into other functions. Functions can be stored in variables, they can be moved around like any other piece of data in JavaScript. That is not true for every other languages.

For now, we will talk about the ability to put functions into variables.  And this video will go over all the different ways to declare functions. 

Create a new file in our `custom-functions` directory called `ways-to-make-a-function.js`.  Add `console.log('it works')` and go back into the `index.html` file and change the path in the `src` attribue on the script tag to `<script src="./ways-to-make-a-function.js"></script>`. Refresh the browser to ensure that it works. 


We already know one way to declare a function and that is through the function keyword. 

```js
function doctorize(firstName){
  return `Dr. ${firstName}`;
}
```

Now let's see how we can actually declare that, in other ways. Comment that out. 

The next way to create a function is an anonymous function, which is a function without a name. 

To make `doctorize` an anonymous function, you would modify it like this:

```js
function(firstName){
  return `Dr. ${firstName}`;
}
```
However, it's not actually valid javascript in this case. If you try running it in the console you will see an error that says
>Function statements require a function name
However they are valid in many other use cases, specifically using them in callbacks (we will learn about that) as well as in an IIFE (immediately involved function expression). However in this examlpe it is not valid javascript.

Why would you ever want an anoymous function? The next way to declare a function will help explain that.

Add a comment `//AnonFunction` above that function, copy it and then comment it out. Paste the copied code below the commented out function. 

The next way to declare a functino is a function expression. A function expression is when you store a function as a value in a variable. 

```js
//Function Expression
const doctorize = function(firstName){
  return `Dr. ${firstName}`;
}
```

What we did above is we took an anonmyous function and stuck it in a variable. If you refresh the page, you will see that in the console, we have doctorize available to us, and we can call it like we did in previous videos.

![](@attachment/Clipboard_2020-01-29-18-48-13.png) 

That is what people mean when they say functions are first class citizens. WWhat we are doing there is we are creating a variable and then storing the function in that variable name.

You may come across developers who say to not use function expressions because it gives bad errors. Here is an example that demonstrates what they mean by that:

```js
//Function Expression
const doctorize = function(firstName){
   doesntExist();
  return `Dr. ${firstName}`;
}
```
![](@attachment/Clipboard_2020-01-29-18-51-45.png)

What used to happen is the error would just tell you that it occured in an anonymous function and you'd have no clues to lead you to where the error is happening. In our case, it does now tell you it happens inside of doctorize on line 12. 

Although the function is technically an anonymous function without a name, the browsers will now infer the name of the function from the variable name and use that in the errors.

What is the difference between doing a function declaration and a function expression? Why would you want to use one over the other?

There is only one real difference (beside error handling which isnt really an issue anymore) is how they operate how they operate in something called **hoisting**. We will go over this in a future video but we will go over it quickly now.

Add to the .js file a `doctorize2` function. 
```js
const doctorize = function(firstName){
  return `Dr. ${firstName}`;
}
function doctorize2(firstName){
  return `Dr. ${firstName}`;
}
```

If on the line before the first `doctorize` function, we were to add `doctorize("wes")`, do you think that it will run? If you run a function before you define it, does it work? 

Nope! You get an error like:

>Uncaught ReferenceError: Cannot access 'doctorize' before initialization
>    at ways-to-make-a-function.js:78
>(anonymous) @ ways-to-make-a-function.js:78

What about doctorize2? 

```js
console.log(doctorize2("wes"));

const doctorize = function(firstName) {
  return `Dr. ${firstName}`;
};
function doctorize2(firstName) {
  return `Dr. ${firstName}`;
}
```

It does work! The function declaration works, but the function expression does not work if you call it before you define it. Why?

Even though those are the exact same functions we have created, because you define a regular function with a function keyword and the other one with a variable, functions that are declared with the fucntion keyword are called hoisted.

That means that javascript takes all functions and hoists them up, up, up and says you're a function, you belong at the top of the file so that anywhere that you call the function it will be available to you. Javascript does **not** hoist variable functions. 

Why is that useful? Very rarely, Wes has never used that in his entire career except tiny use cases. 

Hoisting is more of an interview question that you may be asked. 
Essentially it means that javascript will take functions and bring them up before the yare called. You can technically run a function before it is defined with that ability. 

In `ways-to-make-a-function.js`, clear out the second doctorize2 function and just leave the function expression. 

**Arrow Functions**

The next way to make a function is using an arrow function. Arrow functions themselves have a few different ways of being declared. We will go over those now. 

Arrow functions are an addition to javascript which was addedi n the last couple of years.

They offer a couple of things. 

First, they have a concise syntax and are shorter. Often with tings like callbacks, its simpler to use an arrow function to write a one liner function. 

Another benefit is that they do not have their own scope in reference to the `this` word (we will go over `this` in more depth in the future).

Arrow functions are anonymous functions, which means there is no way to declare an arrow function the way we do a function declaration `function doctorize(){..}`. You always have to stick it into a variable.

To illustrate this, we will begin by writing a regular function. 

```js
function inchToCM(inches){
  const cm = inches * 2.54;
  return cm;
}
```

This function will take in inches and return centimeters. Let's try it ion in the browser. 

![](@attachment/Clipboard_2020-01-30-17-50-07.png)

This is a pretty simple function, but it still takes up four lines of code. We can make it a bit shorter by instead of creating a variable and then returning a variable, you can just return the calculation itself. 

![](@attachment/Clipboard_2020-01-30-17-52-26.png)
Note: you may notice in the screenshot that the return cm is now greyed out. That is because that code is unreachable which happens because we are returning on the line above, and when you return from a function, that function is finished running.

```js
function inchToCM(inches){
  return inches * 2.54; 
}
```

Now we can convert it to an anonymous function as a step on the way to making it an arrow function.

```js
const inchToCM = function(inches){
  return inches * 2.54; 
}
```

Refresh the page to check that it still works (it does!).  It still works in the same way, now we just have made it an anonymous function and stored it in a variable. 

Now we will go ahad and convert that function over to an arrow function. 
There are a couple of different ways we can do that, which we will go over now. 

Instead of writing the word function, we will delete it like so:

```js
const inchToCM = (inches){
  return inches * 2.54; 
}
```

Now we will go to the right of the paranthesis and add what is called a fat arrow `=>`.

In programming, `->` is referred to as a skinny arrow and `=>` is referred to as a **fat arrow**. 

```js
const inchToCM = (inches) => {
  return inches * 2.54; 
}
```

You might notice if you save, prettier will modify the function and remove the paranthesis which we do not want because we want to change it to an arrow function in steps. To disable that, add `/* eslint-disable */` right above the function. 

Note: the spaces between `(inches) => {` does not have to be there, `(inches)=>{` still works, but it's more readable with spaces.

If you refresh the page and run it in the console, you will see that it still works.

The next thing we will do is what is called an **implicit return**. 

An explicit return is when you type the return keyword, like in `return inches * 2.54`. That is an explict return meaning that we explicitly return the value there. 

And implict return is returning it without actually having to type the keyword return. Arrow functions allow us to return a value without having to type the keyword `return`. 

First, we will put the function on one line like so: 

```js
const inchToCM = (inches) => { return inches * 2.54;};
```

To get rid of the explicit return, first you put it on one line, delete the curly brackets`{` `}` and delete the keyword. 

`const inchToCM = (inches) =>  inches * 2.54;`

So what we did there is we made an arrow function called inchTocM which takes in one argument called `inches`, and then it implicitly returns the value. 

The way we can tell this is an implicit return is that:
1. it's all on one line
2. there is no return keyword
3. there are no curly brackets. 

If you refresh in the browser, you will see that it still works.

To recap: what we did there is we removed the function block, modified the code to be on one line, and removed the explicit return. 

Finally, and this is more of a stylistic choice, if there is only ever one parameter for your function, you can actually get rid of the paranthesis around the parameter as well, like so

```
const inchToCM = inches =>  inches * 2.54;
```

That is still your arrow function, we have just taken the paranthesis off because if there is only one parameter in your function, you can remove them no problem. 

Let's do another example!

Make a function called `add`, that takes in two parameters (first one `a` and second one`b`), we have set a default value of 3 in b. Then we make a temporary variable called total which we return.

```js
function add(a, b = 3) {
  const total = a + b;
  return total;
}
```
Pause the video now, try to convert it to an arrow function yourself and then come back to the video.

Let's first see if it works as it originally was. Save the code from above and refresh `index.html` in the browser. Open the console and test the function.

![](@attachment/Clipboard_2020-01-30-19-48-27.png)

You might notice that dev tools is giving us an annotation (?b), and that little question mark infront of b is telling us that the argument is optional. (`b` if optional because there is a default value to fall back on)

First thing we will do is stick the function in a variable calld add and remove the function name. `const add => function(a, b = 3) }`

Next we will convert it to an arrow function. Get rid of the keyword function and add a fat arrow to the right of the paranthesis. 

```js
const add = (a, b = 3) => {
  const total = a + b;
  return total;
}
```

Next we will return just `a + b` and get rid of the total variable. 

```js
const add = (a, b = 3) => {
  return a + b;
}
```

The next thing is put it on it's own line.

```
const add = (a,b = 3) => { return a + b; }
```

Then we can get rid of the function block and return keyword. 

```js
const add = (a, b = 3) => a + b;
```

Now we have a short arrow function! You may have noticed that we did not get rid of the parentheses, and that is because there is more than one parameter. 

There are a couple of other gotchas with arrow functions that we need to know about. Let's go over them now.

**Returning an object**

let's make a function called `makeABaby()` that will take in the babies first and last name. Inside of the function we will have an object call baby, with a name and age.

```js
function makeABaby(first,last){
  const baby = {
    name: `${first} ${last}`,
    age: 0
  }
  return baby;
}
```


It works!

![](@attachment/Clipboard_2020-01-30-19-58-43.png)

How would we convert this to an arrow function? First we will stick it in a variable, and convert it to an arrow. 

```js
 const makeABaby = (first,last) => {
  const baby = {
    name: `${first} ${last}`,
    age: 0
  }
  return baby;
}
```

If your function needs to do some stuff inside of the block, you can leave it as is. This is a perfectly valid arrow function. If the only thing you're using the arrow for is the ablity to type less as well as some of the benefits of not scoping this, this is totally valid.  However we can take it a bit further. 

Instead of declaring the baby variable we will just return the object directly.

```js
 const makeABaby = (first, last) => {
     return {
       name: `${first} ${last}`,
       age: 0
     };
  };
```

Now the question is... how would we do the implicit return?
We can put it on one line, no problem. (Objects can be put on one line).
But how would we return it. Let's try it. 

First put it on one line.

```js
const makeABaby = (first, last) => {return { name: `${first} ${last}`, age: 0}};
```

Now if we want to make it an implicit return, we get rid of the curly brackets and the return. 

```js
const makeABaby = (first, last) => { name: `${first} ${last}`, age: 0};
```

However, you will see this error if you try to run the code like that.
![](@attachment/Clipboard_2020-01-30-20-06-08.png)

Whats happening there is it thinks that the curly bracket from the baby object is actually the curly object from the block of the function. Curly brackets in javscript can be creation of an object, or a block of code. So how do you implicitly return an object when it gets confused about what it actually is. 

If you want to implictly return an object in javascript, you just pop a set of parentheses around the thing that you are returning and that will contain it and it won't think it's the block fo the function. 

```js
const makeABaby = (first, last) => ({ name: `${first} ${last}`, age: 0});
```

If you try it in the code, it still works.

Now is there a benefit of having the function this way or how we did it originally? Wes doesn't think so. Youre not really getting much benefit, in fact the way we had it originally was a bit more readable. 

There is nothing wrong with doing a regular function, because you want to think about your future self. Let's say you come back to the code in 6 months, what will be easier for you to read? Don't always go to making an arrow function by default, and hopefully throughout this course it will become more clear when you should reach for an arrow function (specifically with arrays and doing maps and reduce and filters).

**IIFE**
The next way to clear a function is using an IIFE (pronounced iffy). 
That is an immediately invoked function expression. 

We will do an example to demonstrate was an IIFE is. 

Add this function to our code (comment out the other code) and refresh `index.html`.

```js
function(){
  console.log('Running the Anon function');
  return `Your are cool`;
}
```

Nothing happens when you refresh `index.html` because it's not allowed to. We talked about how you can stick a function in a variable and that is okay. Another way to run this function is what is called an immediately invoked functional expression. 

What you can do is wrap that function in a parantheses, (parentheses always run first in javascript), and what that will do is return a function value and you can immediately run that function by putting paranthesis on the end like so:

```js
(function(){
  console.log('Running the Anon function');
  return `Your are cool`;
})();
``` 

Now, if you refresh the page, you will see the console.log which means that our function expression was immediately invoked. It was immediately run. 

What is the benefit of doing something like that? It used to be very popular before we had modules and block scope, you will realize when we get into scoping that a function declares its own scope and its often handy to even declare functions inside of the thing, and it will provide us a sheltered space where the variables can't leak inside. We will go over that later in the course. 

For now, just know that it's an immediate invoked function. 

One last thing is what if the function took an age? You would pass it like so:

```
(function(age){
  console.log('Running the Anon function');
  return `Your are cool and ${age}`;
})(age)
```

That isn't something you will be using that often, but it does come up when you need to create something like a closure (epxlained in future video). 

**Methods**

Next type of function we have is called methods. 

Wes has so far sort of been saying that methods and functions are the same thing and we have a video coming up that focused entirely on creating your own methods.  

A method is simply a function that lives inside of an object. 

If we take a look at the function `console.log` in the browser, so far Wes has been telling us that `console.log()` is a function. But he has been lying to us.   

`log()` is actually the functino that lives inside of console, and console is actually an object. If you type `console` into the console and open it up, you will see that there are all kinds of things within it.

![](@attachment/Clipboard_2020-01-30-20-26-46.png)

Scroll down to log, and the little f ![](@attachment/Clipboard_2020-01-30-20-27-19.png) you see means that it's actually a function.

So `console` is the object and `log()`, `count()` or any of the other functions listed under the console object are the functions. 

We have a special word to describe functions that live inside of an object and we call those methods. 

So we can actually do something like this..

```js
const wes = {
  name: 'Wes Bos',
  sayHi: function(){
    console.log('Hey wes!');
    return 'Hey Wes!';
  }
}
```

Try it in the browser, first type `wes` and hit enter and next type `wes.sayHi()` and hit enter. You should see the following:
![](@attachment/Clipboard_2020-01-30-20-30-25.png)

Wes.sayHi() is a method. You make it a property on your object and you set it to a function.

Those functions can also have names. Sometimes you will see something like this:

```js
const wes = {
  name: 'Wes Bos',
  sayHi: function sayHi(){
    console.log('Hey wes!');
    return 'Hey Wes!';
  }
}
```

Wes doesn't see the point of doing something like that, but it is technically allowed. 

There is also a new shorthand method. 

```js
const wes = {
  name: 'Wes Bos',
  // Method!
  sayHi: function sayHi(){
    console.log('Hey Wes!');
    return 'Hey Wes!';
  },
  //Short hand Method
  yellHi(){
    console.log('HEY WESSSSS');
  }
}
```

If you refresh the browser and type `wes.yellHi()`, it will work.  

What we did there is instead of writing `sayHi: function()`, which will work, we can get rid of the function keyword and the colon and what that will do is make a property called `yellHi()` set to a function `yellHi`. It's just a shorthand way to write methods inside of an object.

There is another way, which is an arrow function. 

```sj
const wes = {
  name: 'Wes Bos',
  // Method!
  sayHi: function sayHi(){
    console.log('Hey Wes!');
    return 'Hey Wes!';
  },
  //Short hand Method
  yellHi(){
    console.log('HEY WESSSSS');
  }
  //Arrow functino
   whisperHi: () => {
     console.log('hiii wess im a mouse');
   }
```

`whisperHi()` is an arrow function that doesn't take any arguments, but it could take in arguments if you wanted.

Those are three different ways to do methods and the short hand is the most common way.
The only reason you would do an arrow function is because you don't want to access this.

The only reason you would do an arrow function is because you don't want to access this. We will go over that when we get to objects but really quickly Wes will show us. 

If you modify the `sayHi()` method to add `console.log(this);` and ran it in the browser

```js
 sayHi: function sayHi(){
    console.log(this);
```
You will see that on the line in our code that we console logged, we will see the value of `this` returned. 

![](@attachment/Clipboard_2020-01-30-20-43-26.png)

`this` is equal to the object that it was called against. That is cool because you could actually do something like this:

```js
const wes = {
  name: 'Westopher Bos',
  // Method!
  sayHi: function sayHi(){
    console.log(`Hey ${this.name}`);
    console.log('Hey Wes!');
    return 'Hey Wes!';
  },...
```

You would see it immediately fulls the value of the name property. 

![](@attachment/Clipboard_2020-01-30-20-44-42.png)

That will not work in an arrow function because they take the parent scope of this. We will explain that in the future. 


**Callback Functions**
The final thing Wes wants to talk to us is something called callback functions.

So a callback function is just a regular function, but we sort of use that name for something that will happen when something is done. The easiest way to define a callback function is either when someone clicks something, run this. Or when this amount of time has passed, run this.

Let's look at both of those examples.

**Example 1**

We will do a click callback. 

Go into our `index.html` file and give ourselves a button that say click me and give that a class of `clickMe`.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title></title>
    <link rel="stylesheet" href="../../base.css" />
  </head>

  <body>
    <button class="clickMe">Click Me!</button>
    <script src="./ways-to-make-a-function.js"></script>
  </body>
</html>
```

Go back to the javascript file. 

We will select the element (we will go over in depth more about the DOM later) like so

```
const button = document.querySelector('.clickMe');
console.log(button);
```
Refresh the page and open the console to see that it works.

![](@attachment/Clipboard_2020-01-30-20-57-19.png)

Now we are goign to listen for a clikc on that button like so:  

```
const button = document.querySelector('.clickMe');
button.addEventListener('click', wes.yellHi());
```

When that click hapens, we can pass it to any function that we want. in this case, we chose `sayHi()` from our `wes` object from a previous example. 

Now, everytime you click it, it will say HEY WESSSS

![](@attachment/Clipboard_2020-01-30-20-59-21.png)


What is happening there is that `.addEventListener()` is an event listener that we are listening for a click on, and the callback function is `wes.sayHi()`. 

It's a functino that we give it access to. Notice that we are not running it there, we are just saying here is the function dear browser, when someone clicks that button please be a dear and calll that function. That is what is referred to as a callback function.

Callback functions can be declared outside of the handler, so making a function like

```js
function handleClick(){
  console.log('Great clicking!!');
}
button.addEventListener('click', handleClick);
```

What we are telling the browser to do here is that when someone clicks the element with the class '.clickMe`, run the functino called `handleClick`. 

 The other option, that is probably half as common, where you define the function outside and then pass in the reference to the function. 
Another thing you can do is just pass it an anonymous function. You can do this

```

button.addEventListener('click', functino(){
  console.log('nice Job!');
});
```

![](@attachment/Clipboard_2020-01-30-21-06-26.png)

And it works just fine when you press it. 

What we have done there is we have passed it an anonymous function as a value directly and the browser will know to call this function itself. There are upsides and downsides of doing it that way which we will get into another time. 

What you need to know is that a callback function is a function that gets passed into another function and then it is called by the browser at a later point in time.

The other example we have is a timer callback. There are a couple way to do timers (we will go over all of them in the future) but the simplest is `setTimeout()`.

```
setTimeout();
```

It takes two things:
1. a function to call after a certain amount of time
2. a duration in milliseconds (after how long should I run this)


So let's do `1000` milliseconds which is one second later. If we run the page after one second, it will run 

```js
setTimeout(wes.yellHi(), 1000)
```

If we run the page after one second, it will run HEY WES. 

You can also pass it an anonymous function.

```
setTimeout(function(){
  console.log('DONE TIME TO EAT');
}, 1000);
```
After a second that will console log DONE TIME TO EAT.

You can pass those as arrow functions as well.


```js
setTimeout(() => {
  console.log('DONE TIME TO EAT');
}, 1000);
```

That will work the same!

---

## 16 - Debugging Tools

There are two parts of debugging: 
1. there are tools you can use to get info when things go wrong
2. the right mindset to be a good problem solver

This video will focus on the tools. What Wes' hopes for is that as you go through the course, anytime we start to hit a roadblock, Wes won't cut it out of the video, he will leave it in and show us his thought process.

Go into the exercises folder, there is a folder 16 called Debugging and then inside of that there is a file called `debugging-START.js` and `debugging.html`. 
If you open `debugging.html`, you will see that it's just a basic html file where we are loading base css, we have a button that says make me bigger and then a script tag that is loading `debugging.js` which doesn't exist yet. Make a copy of the `debugging-START.js` file and save it as `debugging.js`. 

This file contains a bunch of stuff we haven't learned yet: arrays of objects, loops, functions, event listeners, etc. It doesn't matter that we don't know what all those different things do yet, Wes will explain that later and we will learn how to build our own. This is more so we can test different types of debugging. 

We will start with console debugging. 

There is `console.log()` which is the most common one you'll see. 

```
people.forEach((person, index) => {
  console.log(person.name);
});
```

There is `console.info(person.name)` which usually gives you a little eye and cirlce beside the console output but it doesn't seem to be there right now.

There is `console.error(person.name)`. That isn't used for throwing or handling errors (we will learn about that), this just changes what the log looks like in the console. 

![](@attachment/Clipboard_2020-01-31-17-46-02.png)

It also gives you a stack trace:
![](@attachment/Clipboard_2020-01-31-17-47-21.png)

There is `console.warn()` which is very similar to `console.log()` 

![](@attachment/Clipboard_2020-01-31-17-47-38.png)

There is `console.table()`. Anytime you have a list of objects, and the objects have the same property (meaning the objects all have `name`,`cool`, and `country` properties), `console.table()` will format that into a nice little table.

```
console.table(people);
```
![](@attachment/Clipboard_2020-01-31-17-49-45.png)

There is `console.count()`. This is useful if you want to know how many times a function is being run. If we go into the `doctorize()` function in `debugging.js` and add a `console.count('runinng doctorize');`, and then refresh the html page, now everytime you type `doctorize('wes');` in the console, the console will log a count. 

![](@attachment/Clipboard_2020-01-31-17-52-29.png)

That is useful in a scenario where you aren't sure if a function is running twice, or somethings you are working with hover elements and it's getting triggered way too often. `console.count()` will show you how many times it's actually running. 

You can also pass variables to `console.count()`. If you were to change the example to backticks

```
function doctorize(name) {
  console.count(`running Doctorize for ${name}`);
  return `Dr. ${name}`;
}
```

Now if you type in the console `doctorize('wes')`, it will show the count, but if you run `doctorize('snickers');`, it goes back to one. 

![](@attachment/Clipboard_2020-01-31-17-57-25.png)

But if you call `doctorize('wes');` again, it maintains that. 

![](@attachment/Clipboard_2020-01-31-17-58-57.png)

So it's based on what strings you pass to the console.count().

Next we have `console.group()`, that can be helpful if you have a bunch of stuff to console.log(). 

We will make a function `doALotOfStuff` to demonstrate. Comment out all of the example consoles we have gone over so far. 


Add `console.group("Doing some stuff")`, and then underneath it add a few more consoles such as log, warning, error. Then add `console.groupEnd()` and pass it the same string we had passed to `console.group()`. 

```js
function doALotOfStuff() {
  console.group("Doing some stuff");
  console.log("Imone");
  console.warn("watch out!");
  console.error("hey");
  console.groupEnd("Doing some stuff");
}
```

![](@attachment/Clipboard_2020-01-31-18-15-45.png)

What it does is it groups together all of `console.log()` into a groupable thing, and that can be very helpful. We will do another example in the `people.forEach()` method. 

```
people.forEach((person, index) => {
  console.group(`${person.name}`);
  console.log(person.country);
  console.log(person.cool);
  console.log("DONE!!");
  console.groupEnd(`${person.name}`);
});
```

![](@attachment/Clipboard_2020-01-31-18-20-52.png)

It nicely organizes the people into their separate collapsable section.

You can actually also do `console.groupCollapse()` which will by default collapse all the groups. 
![](@attachment/Clipboard_2020-01-31-18-22-08.png)

Those are the main console methods that Wes uses to debug something.

Comment out all the `console.group()` code. 

Next we will talk about something called the **call stack** or the **stack trace**. The stack trace will tell you which function called what function calledw hat functino.

If you scroll down to the function `go()`, you will see that it calls `doctorize()`, which will first call greet. There is a lot going on in that.

![](@attachment/Clipboard_2020-02-01-14-03-17.png)

You will notice that inside of `greet()` we have this function that doesn't exist, and that wil cause an error. If we try to run that from the console, you will see an uncaught reference error. 

If you expand the error, you will see a few message below, that is often ignored by new developers but is actually very useful in debugging. 
If you want to know what went wrong, you have to get good at reading the call stacks. It's pretty simple!

![](@attachment/Clipboard_2020-02-01-14-04-35.png)

What that is saying is the error hapened hre, at `greet()` which is on line 47 of `debugging.js`, which is where the actual error hapepned. 

That is good, but errors aren't always that easy. You might need to know where the `greet()` function was called from. 

So you go to the next line which tells you that it was was called by `go()` on line 52. And then it says `at <anonymous>:1:1`. What does that mean? That is because we called it from the console. If we actually made another function that called go instead like so:

```
function bootstrap(){
  console.log('starting the app!);
}
```

Now if you call `bootstrap()` from the console, you will see:
![](@attachment/Clipboard_2020-02-01-14-19-44.png)

If you were to modify `debugging.js` to add a call to bootstrap on page load like so: `bootstrap();`, you won't see that anonymous function line in the call stack.

![](@attachment/Clipboard_2020-02-01-14-23-12.png)

Now comment out the `bootstrap()` call. 

Next we will learn about the grabbing of elements. This is a handy tip that Wes' uses often. If you're on a website, and you're inspecting it, and focusing on an element such as this input from Mozilla's website by clicking on it in the element inspector, if you flip over to the console and type `$0`, it will return to you whatever element you had currently selected in the elements tab.

![](@attachment/Clipboard_2020-02-01-14-26-11.png)

![](@attachment/Clipboard_2020-02-01-14-28-02.png)

That is very useful because now you could do something like call `$0.value()` against it, and it will tell you what you have typed inside the input.

![](@attachment/Clipboard_2020-02-01-14-29-12.png)

You might be wondering, what does `0` int the `$0` mean. It means the last element that was clicked. If you were to go back to the elements tab, select another element like a button, when you go back to the console `$0` will give you the button element at `$1` will give you the input. 

![](@attachment/Clipboard_2020-02-01-14-30-30.png)

You can keep going forever, if you click another element, it will remembering the order in which they were clicked. 

Another cool thing you do is the use the `$` and `$$` symbol in the console. You cannot use these things in your code, it only works in the console. Also, if jQuery is loaded on the page, that won't work.

![](@attachment/Clipboard_2020-02-01-14-32-34.png)

Those are shorthand selectors for two things we will learn about in a future video about the DOM. Those selectors will allow us to select things based on selectors. 

`$('p')` will give us `document.querySelector()`, which will match the first thing that matches the selector passed.  whereas `$$('p')` will match ALL of the elements that match the selectors. 

![](@attachment/Clipboard_2020-02-01-14-39-56.png)

In the value returned from `$('p')` you can see it found the first paragraph, and with `$$('p')`, it found all of the `p` elements on the page. 

Next we will talk about breakpoints.

Go into the `people.forEach()` method and delete all the console.logs that we had commented out within it and add a `console.log(person.name);`. If you refresh the html page, you will see everyones name logged to the console.

What you can do is, within the `people.forEach()` method, if you want to pause javascript from running, you can type `debugger;`, like so:

```js
people.forEach((person, index) => {
  debugger;
  console.log(person.name);
});
```

![](@attachment/Clipboard_2020-02-03-17-29-52.png)

That is a statement that only takes into effect when your dev tools are open, and it will pause javascript from running and allow us to peer into javascript at that very moment.

If you refresh `debugging.html` now, what happens is that we have set what is called a **breakpoint**. What you are saying when you set a breakpoint is you are telling javascript to break at this certain time. 

![](@attachment/Clipboard_2020-02-03-17-32-49.png)

This gives you a whole bunch of information as to what happened. 

If you hover over it, it will show you what the variables are equal to at this point in time: ![](@attachment/Clipboard_2020-02-03-17-34-11.png)

You can see that the javascript has paused and if you go to the console, you will see that nothing has been logged yet. Flip back to the sources tab.

On the right handside of the `Sources` tab, that is where all the different tools for inspecting what is going on live. 

![](@attachment/Clipboard_2020-02-03-17-35-42.png)

We get the callstack, which we learned about earlier. Second it will let us nkow what the local variables are. 

You can expand the collapsed Local section within the Scope section, or hover over a variable to see it's value. 

![](@attachment/Clipboard_2020-02-03-17-37-13.png)

There are other sections for breakpoints which we will get to in a second.

What is cool is you can click the play button right here, ![](@attachment/Clipboard_2020-02-03-17-38-09.png) and then if you flip back to the console, you will see that the name "Wes" has been logged.

What happened there is when the function first ran, it hit the breakpoint and then when we pressed play, it logged the first persons name and then because it's in a loop, it hit the breakpoint again and paused. Now you can see that the second person is equal to Scott. 

![](@attachment/Clipboard_2020-02-03-17-39-21.png)

You can also step over into the next function call like so
![](@attachment/Clipboard_2020-02-03-17-43-28.png)

When you hit play, it will just continue execution of the code until it hits the next breakpoint. If you click the option beside the play button that says "Step over next function call", it allows you to run the code line by line. 

GIF: https://cl.ly/e6eee78faefc

When you feel like you are console.logging too much data in order to see it, or you are console.logging something quickly so you can see what happened in the past, adding a debugger (it can go anywhere in your javascript code) can be very helpful. 

It's a handy way to slow things down and peer into what the different pieces of data are. 

You can also set breakpoints from the browser as well. 

Remove the line of code in `debugger.js` that says `debugger;` and refresh `debugging.html` in the browser. Open the sources tab. 

![](@attachment/Clipboard_2020-02-03-17-50-42.png)

In the sidebar on the left, you can click on your actual javascript files that are loaded on the page, and then you can say something like "when someone runs this go() function, I want to put a breakpoint in there"

![](@attachment/Clipboard_2020-02-03-17-55-27.png)

What you do is you click the line number next to the line of code that you would like to pause during.  If you go into the console and type `go()`, you will see that the code pauses itself in the debugger at the line where you set the breakpoint. 

Recap: you can either create the breakpoint by clicking next to the line number in the sources tab, or adding the word `debugger;` anywhere in your javascript. 

Always make sure you remove those `debugger;` calls from your code once you are finished!

We talked about scope. Scope will allow us to peer into what variables are, we will look at that more in the next video. 

The next one is Network Request. This is useful if you want to see what is being fired off when you load the page. If you go to your networks tab and refresh `debugging.html`, you will see all of the different files that are needed in order for the page to work. 

![](@attachment/Clipboard_2020-02-03-18-00-04.png)

This is helpful because you can see when is sending out data for you. 

Wes added a function to `debugging.js` called `fetchDadJoke()`. What that function will do is go off to an API and grab a random dad joke. Don't worry about what all the lines of code mean here, we will go over that in future videos. For now, know that it goes to an external API and grabs an API. 

```
// A Dad joke fetch
async function fetchDadJoke() {
  const res = await fetch("https://icanhazdadjoke.com/", {
    headers: {
      Accept: "text/plain"
    }
  });
  const joke = await res.text();
  console.log(joke);
  return joke;
}
```

If you were to run the `fetchDadJoke()` function in the console, it will return a dad joke and log it to the console. 

If you go back to the network tab, you will see that there is a new item that has been logged. 

![](@attachment/Clipboard_2020-02-03-18-03-09.png)

This tells you the information about the request, what actually hapened, the raw response and a preview of it. It gives you information such as how long did this request take. 

![](@attachment/Clipboard_2020-02-03-18-04-09.png)

If you're website is slow for example, it will tell you how long the request took, and where the time was spent. 

If you go to http://apple.com for example and inspect the network tab, you will see that there are 100s of things that are requested. You can also filter out the requests within the network tab such as XHR, which is when they're sending data out about you. 

![](@attachment/Clipboard_2020-02-03-18-06-25.png)

Next we will go over break on attribute. Wes doesn't use this one often, but it can be useful. 

On `debugging.html` there is a button that says "Make me bigger". 

![](@attachment/Clipboard_2020-02-03-18-08-59.png)

When you click it, it gets bigger. If you go to your elements, you will see that the font-size is just being bumped up everytime the button is pressed. If you don't know where the javascript is that is making that button bigger, you can go into you button in the elements tab of dev tools and select "Break on -> Attribute Modifications". 

![](@attachment/Clipboard_2020-02-03-18-10-14.png)

This is just another way of adding a breakpoint. There is also something called subtree modifications which means that when somebody adds like a div, and then there is something called node removal which is when someone removes an element or text from something. We will just do attribute modifications. 

Set the breakpoint on attribute modification and now when we click the button, the breakpoint should be triggered and bring us to the sources tab which will show you where that attribute is being modified from. 

GIF: https://cl.ly/9c5a8f8b9d07

That is very useful when you get thrown into a random code base where you don't really know what is going on.

Finally, if you go to the sources tab again, you will see that there are other things on the righthand side. 

![](@attachment/Clipboard_2020-02-03-18-17-49.png)

You can throw eventlistener breakpoints, such as mouse click.

![](@attachment/Clipboard_2020-02-03-18-18-28.png)

If you add that breakpoint, now when you click on the button, it will throw a debugger breakpoint for you. 

There are also XHR breakpoints:
![](@attachment/Clipboard_2020-02-03-18-19-34.png)

If you click `Any XHR or fetch`, what that will do is anytime a fetch request is made, anytime someone goes off to an external API, the code will break. 

To test this you can set the breakpoint option and then go into the console and try typing `fetchDadJoke()`. You will see that it pauses in the debugger where the fetch request is made and we can actually step through it.

Wes would estimate that around 98% of the debugging that he does is done using console.log, breakpoints and network requests. He will turn to the other types of debugging tools available typically in severe edge cases where he is stumped. 



